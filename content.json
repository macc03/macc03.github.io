{"meta":{"title":"Macc的个人博客","subtitle":"","description":"","author":"Macc","url":"https://macc03.github.io","root":"/"},"pages":[],"posts":[{"title":"Hexo搭建个人博客","slug":"Hexo搭建个人博客","date":"2021-07-15T09:56:42.000Z","updated":"2021-07-15T10:37:08.071Z","comments":true,"path":"Hexo搭建个人博客/","link":"","permalink":"https://macc03.github.io/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Hexo搭建个人博客一、环境准备1.安装Nodejs(Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) 进入nodejs官网，下载并安装 2.安装Git 进入Git官网,下载安装 二、安装hexo进入命令行输入： 1$ npm install -g hexo-cli 等待安装完毕 三、搭建博客在D盘新建一个博客目录，右键进入Git Bash，输入命令： 12$ hexo init$ npm install 输入命令： 1hexo s 进入浏览器，输入上面网站，可以看到服务已经运行起来 接下来把它部署到Github账号 三、部署到Github新建一个Github账号,点击New新建一个仓库 Repository name改成你的名字+’.github.io’，比如macc03.github.io 勾上选择框,点击创建 将git与远程仓库绑定进入GitBash,输入 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 将名字和邮箱改为你的 输入 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 生成公钥 进入C:\\Users\\user\\.ssh目录，复制id_rsa.pub的内容 进入GitHub，头像下面的设置界面，点settings，然后点SSH and GPG keys 新建一个SSH key 粘贴就行了 编辑博客目录的_config.yml文件，把最下面的改为 repo改为你github的仓库地址 上传到GitHub1$ npm install hexo-deployer-git --save 安装hexo-deployer-git 在GitBash中输入 1git add . 1git commit 就可以看到效果了 (完) （功能没有做，只是静态页面）","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://macc03.github.io/tags/hexo/"}]},{"title":"Javascript的Map和Set","slug":"Javascript的Map和Set","date":"2021-07-13T06:53:17.000Z","updated":"2021-07-13T06:56:29.548Z","comments":true,"path":"Javascript的Map和Set/","link":"","permalink":"https://macc03.github.io/Javascript%E7%9A%84Map%E5%92%8CSet/","excerpt":"","text":"Map and Set（映射和集合）我们已经了解了以下复杂的数据结构： 存储带键的数据（keyed）集合的对象。 存储有序集合的数组。 但这还不足以应对现实情况。这就是为什么存在 Map 和 Set。 MapMap 是一个带键的数据项的集合，就像一个 Object 一样。 但是它们最大的差别是 Map 允许任何类型的键（key）。 它的方法和属性如下： new Map() —— 创建 map。 map.set(key, value) —— 根据键存储值。 map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。 map.has(key) —— 如果 key 存在则返回 true，否则返回 false。 map.delete(key) —— 删除指定键的值。 map.clear() —— 清空 map。 map.size —— 返回当前元素个数。 举个例子： 123456789101112let map = new Map();map.set(&#x27;1&#x27;, &#x27;str1&#x27;); // 字符串键map.set(1, &#x27;num1&#x27;); // 数字键map.set(true, &#x27;bool1&#x27;); // 布尔值键// 还记得普通的 Object 吗? 它会将键转化为字符串// Map 则会保留键的类型，所以下面这两个结果不同：alert( map.get(1) ); // &#x27;num1&#x27;alert( map.get(&#x27;1&#x27;) ); // &#x27;str1&#x27;alert( map.size ); // 3 如我们所见，与对象不同，键不会被转换成字符串。键可以是任何类型。 map[key] 不是使用 Map 的正确方式 虽然 map[key] 也有效，例如我们可以设置 map[key] = 2，这样会将 map 视为 JavaScript 的 plain object，因此它暗含了所有相应的限制（没有对象键等）。 所以我们应该使用 map 方法：set 和 get 等。 Map 还可以使用对象作为键。 例如： 123456789let john = &#123; name: &quot;John&quot; &#125;;// 存储每个用户的来访次数let visitsCountMap = new Map();// john 是 Map 中的键visitsCountMap.set(john, 123);alert( visitsCountMap.get(john) ); // 123 使用对象作为键是 Map 最值得注意和重要的功能之一。对于字符串键，Object（普通对象）也能正常使用，但对于对象键则不行。 我们来尝试一下： 12345678let john = &#123; name: &quot;John&quot; &#125;;let visitsCountObj = &#123;&#125;; // 尝试使用对象visitsCountObj[john] = 123; // 尝试将 john 对象作为键// 是写成了这样!alert( visitsCountObj[&quot;[object Object]&quot;] ); // 123 因为 visitsCountObj 是一个对象，它会将所有的键如 john 转换为字符串，所以我们得到字符串键 &quot;[object Object]&quot;。这显然不是我们想要的结果。 Map 是怎么比较键的？ Map 使用 SameValueZero 算法来比较键是否相等。它和严格等于 === 差不多，但区别是 NaN 被看成是等于 NaN。所以 NaN 也可以被用作键。 这个算法不能被改变或者自定义。 链式调用 每一次 map.set 调用都会返回 map 本身，所以我们可以进行“链式”调用： 123map.set(&#x27;1&#x27;, &#x27;str1&#x27;) .set(1, &#x27;num1&#x27;) .set(true, &#x27;bool1&#x27;); Map 迭代如果要在 map 里使用循环，可以使用以下三个方法： map.keys() —— 遍历并返回所有的键（returns an iterable for keys）， map.values() —— 遍历并返回所有的值（returns an iterable for values）， map.entries() —— 遍历并返回所有的实体（returns an iterable for entries）[key, value]，for..of 在默认情况下使用的就是这个。 例如： 1234567891011121314151617181920let recipeMap = new Map([ [&#x27;cucumber&#x27;, 500], [&#x27;tomatoes&#x27;, 350], [&#x27;onion&#x27;, 50]]);// 遍历所有的键（vegetables）for (let vegetable of recipeMap.keys()) &#123; alert(vegetable); // cucumber, tomatoes, onion&#125;// 遍历所有的值（amounts）for (let amount of recipeMap.values()) &#123; alert(amount); // 500, 350, 50&#125;// 遍历所有的实体 [key, value]for (let entry of recipeMap) &#123; // 与 recipeMap.entries() 相同 alert(entry); // cucumber,500 (and so on)&#125; 使用插入顺序 迭代的顺序与插入值的顺序相同。与普通的 Object 不同，Map 保留了此顺序。 除此之外，Map 有内置的 forEach 方法，与 Array 类似： 1234// 对每个键值对 (key, value) 运行 forEach 函数recipeMap.forEach( (value, key, map) =&gt; &#123; alert(`$&#123;key&#125;: $&#123;value&#125;`); // cucumber: 500 etc&#125;); Object.entries：从对象创建 Map当创建一个 Map 后，我们可以传入一个带有键值对的数组（或其它可迭代对象）来进行初始化，如下所示： 12345678// 键值对 [key, value] 数组let map = new Map([ [&#x27;1&#x27;, &#x27;str1&#x27;], [1, &#x27;num1&#x27;], [true, &#x27;bool1&#x27;]]);alert( map.get(&#x27;1&#x27;) ); // str1 如果我们想从一个已有的普通对象（plain object）来创建一个 Map，那么我们可以使用内建方法 Object.entries(obj)，该方法返回对象的键/值对数组，该数组格式完全按照 Map 所需的格式。 所以可以像下面这样从一个对象创建一个 Map： 12345678let obj = &#123; name: &quot;John&quot;, age: 30&#125;;let map = new Map(Object.entries(obj));alert( map.get(&#x27;name&#x27;) ); // John 这里，Object.entries 返回键/值对数组：[ [&quot;name&quot;,&quot;John&quot;], [&quot;age&quot;, 30] ]。这就是 Map 所需要的格式。 Object.fromEntries：从 Map 创建对象我们刚刚已经学习了如何使用 Object.entries(obj) 从普通对象（plain object）创建 Map。 Object.fromEntries 方法的作用是相反的：给定一个具有 [key, value] 键值对的数组，它会根据给定数组创建一个对象： 123456789let prices = Object.fromEntries([ [&#x27;banana&#x27;, 1], [&#x27;orange&#x27;, 2], [&#x27;meat&#x27;, 4]]);// 现在 prices = &#123; banana: 1, orange: 2, meat: 4 &#125;alert(prices.orange); // 2 我们可以使用 Object.fromEntries 从 Map 得到一个普通对象（plain object）。 例如，我们在 Map 中存储了一些数据，但是我们需要把这些数据传给需要普通对象（plain object）的第三方代码。 我们来开始： 1234567891011let map = new Map();map.set(&#x27;banana&#x27;, 1);map.set(&#x27;orange&#x27;, 2);map.set(&#x27;meat&#x27;, 4);let obj = Object.fromEntries(map.entries()); // 创建一个普通对象（plain object）(*)// 完成了！// obj = &#123; banana: 1, orange: 2, meat: 4 &#125;alert(obj.orange); // 2 调用 map.entries() 将返回一个可迭代的键/值对，这刚好是 Object.fromEntries 所需要的格式。 我们可以把带 (*) 这一行写得更短： 1let obj = Object.fromEntries(map); // 省掉 .entries() 上面的代码作用也是一样的，因为 Object.fromEntries 期望得到一个可迭代对象作为参数，而不一定是数组。并且 map 的标准迭代会返回跟 map.entries() 一样的键/值对。因此，我们可以获得一个普通对象（plain object），其键/值对与 map 相同。 SetSet 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。 它的主要方法如下： new Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。 set.add(value) —— 添加一个值，返回 set 本身 set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。 set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。 set.clear() —— 清空 set。 set.size —— 返回元素个数。 它的主要特点是，重复使用同一个值调用 set.add(value) 并不会发生什么改变。这就是 Set 里面的每一个值只出现一次的原因。 例如，我们有客人来访，我们想记住他们每一个人。但是已经来访过的客人再次来访，不应造成重复记录。每个访客必须只被“计数”一次。 Set 可以帮助我们解决这个问题： 12345678910111213141516171819let set = new Set();let john = &#123; name: &quot;John&quot; &#125;;let pete = &#123; name: &quot;Pete&quot; &#125;;let mary = &#123; name: &quot;Mary&quot; &#125;;// visits，一些访客来访好几次set.add(john);set.add(pete);set.add(mary);set.add(john);set.add(mary);// set 只保留不重复的值alert( set.size ); // 3for (let user of set) &#123; alert(user.name); // John（然后 Pete 和 Mary）&#125; Set 的替代方法可以是一个用户数组，用 arr.find 在每次插入值时检查是否重复。但是这样性能会很差，因为这个方法会遍历整个数组来检查每个元素。Set 内部对唯一性检查进行了更好的优化。 Set 迭代（iteration）我们可以使用 for..of 或 forEach 来遍历 Set： 12345678let set = new Set([&quot;oranges&quot;, &quot;apples&quot;, &quot;bananas&quot;]);for (let value of set) alert(value);// 与 forEach 相同：set.forEach((value, valueAgain, set) =&gt; &#123; alert(value);&#125;); 注意一件有趣的事儿。forEach 的回调函数有三个参数：一个 value，然后是 同一个值 valueAgain，最后是目标对象。没错，同一个值在参数里出现了两次。 forEach 的回调函数有三个参数，是为了与 Map 兼容。当然，这看起来确实有些奇怪。但是这对在特定情况下轻松地用 Set 代替 Map 很有帮助，反之亦然。 Map 中用于迭代的方法在 Set 中也同样支持： set.keys() —— 遍历并返回所有的值（returns an iterable object for values）， set.values() —— 与 set.keys() 作用相同，这是为了兼容 Map， set.entries() —— 遍历并返回所有的实体（returns an iterable object for entries）[value, value]，它的存在也是为了兼容 Map。 总结Map —— 是一个带键的数据项的集合。 方法和属性如下： new Map([iterable]) —— 创建 map，可选择带有 [key,value] 对的 iterable（例如数组）来进行初始化。 map.set(key, value) —— 根据键存储值。 map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。 map.has(key) —— 如果 key 存在则返回 true，否则返回 false。 map.delete(key) —— 删除指定键的值。 map.clear() —— 清空 map 。 map.size —— 返回当前元素个数。 与普通对象 Object 的不同点： 任何键、对象都可以作为键。 有其他的便捷方法，如 size 属性。 Set —— 是一组唯一值的集合。 方法和属性： new Set([iterable]) —— 创建 set，可选择带有 iterable（例如数组）来进行初始化。 set.add(value) —— 添加一个值（如果 value 存在则不做任何修改），返回 set 本身。 set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。 set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。 set.clear() —— 清空 set。 set.size —— 元素的个数。 在 Map 和 Set 中迭代总是按照值插入的顺序进行的，所以我们不能说这些集合是无序的，但是我们不能对元素进行重新排序，也不能直接按其编号来获取元素。 (转)https://zh.javascript.info/map-set","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://macc03.github.io/tags/javascript/"}]},{"title":"Centos入门基础知识","slug":"Centos入门基础知识","date":"2021-07-12T00:30:51.000Z","updated":"2021-07-12T00:39:25.608Z","comments":true,"path":"Centos入门基础知识/","link":"","permalink":"https://macc03.github.io/Centos%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"Centos入门基础知识 cd /进入根目录。输入命令 ls查看子目录，这些名字是有颜色的： 蓝色 ：文件夹 灰色：普通文件 绿色：可执行文件 红色：压缩文件 天蓝色：链接文件（快捷方式） 常用目录的作用如下： bin： 存放普通用户可执行的指令，普通用户也可以执行； dev ： 设备目录，所有的硬件设备及周边均放置在这个设备目录中； boot ： 开机引导目录，包括 Linux 内核文件与开机所需要的文件； home： 这里主要存放你的个人数据，具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：/home/用户名。当然，root 用户除外； usr： 应用程序放置目录； lib： 开机时常用的动态链接库，bin 及 sbin 指令也会调用对应的 lib 库； tmp： 临时文件存放目录 ； etc： 各种配置文件目录，大部分配置属性均存放在这里； 1.2 目录相关命令 还有几个常用的快捷键： 2. vim 编辑器使用方法vim 编辑器是 CentOS 系统中使用频率比较高的编辑器，掌握基本使用方法对以后的工作有很大帮助。 通过 vim &lt;文件名&gt; 的方式可以编辑某文档，如果文档名不存在，那么会新建一个文档来进行编辑。","categories":[],"tags":[{"name":"centos","slug":"centos","permalink":"https://macc03.github.io/tags/centos/"},{"name":"linux","slug":"linux","permalink":"https://macc03.github.io/tags/linux/"}]},{"title":"js正则表达式","slug":"js正则表达式","date":"2021-07-12T00:30:39.000Z","updated":"2021-07-12T00:38:56.047Z","comments":true,"path":"js正则表达式/","link":"","permalink":"https://macc03.github.io/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"js正则表达式在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。 search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。 replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 12var str = &quot;Visit Runoob!&quot;; var n = str.search(/Runoob/i);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://macc03.github.io/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://macc03.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Css Flex 布局","slug":"Css-Flex-布局","date":"2021-07-12T00:29:12.000Z","updated":"2021-07-12T00:33:09.455Z","comments":true,"path":"Css-Flex-布局/","link":"","permalink":"https://macc03.github.io/Css-Flex-%E5%B8%83%E5%B1%80/","excerpt":"","text":"Flex布局–弹性盒模型转：https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 一、Flex布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 任何一个容器指定为flex布局 123.box&#123; display: flex;&#125; 行内元素也可以使用flex布局 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。 flex-direction （属性决定主轴的方向（即项目的排列方向）。） flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flow1flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 (完)","categories":[],"tags":[]},{"title":"Javascript的数组方法","slug":"Javascript的数组方法","date":"2021-07-11T07:35:55.000Z","updated":"2021-07-12T10:27:04.913Z","comments":true,"path":"Javascript的数组方法/","link":"","permalink":"https://macc03.github.io/Javascript%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"数组方法转载自https://zh.javascript.info/array-methods 数组提供的方法有很多。为了方便起见，在本章中，我们将按组讲解。 添加/移除数组元素我们已经学了从数组的首端或尾端添加和删除元素的方法： arr.push(...items) —— 从尾端添加元素， arr.pop() —— 从尾端提取元素， arr.shift() —— 从首端提取元素， arr.unshift(...items) —— 从首端添加元素。 这里还有其他几种方法。 splice如何从数组中删除元素？ 数组是对象，所以我们可以尝试使用 delete： 12345678let arr = [&quot;I&quot;, &quot;go&quot;, &quot;home&quot;];delete arr[1]; // remove &quot;go&quot;alert( arr[1] ); // undefined// now arr = [&quot;I&quot;, , &quot;home&quot;];alert( arr.length ); // 3 元素被删除了，但数组仍然有 3 个元素，我们可以看到 arr.length == 3。 这很正常，因为 delete obj.key 是通过 key 来移除对应的值。对于对象来说是可以的。但是对于数组来说，我们通常希望剩下的元素能够移动并占据被释放的位置。我们希望得到一个更短的数组。 所以应该使用特殊的方法。 arr.splice 方法可以说是处理数组的瑞士军刀。它可以做所有事情：添加，删除和插入元素。 语法是： 1arr.splice(start[, deleteCount, elem1, ..., elemN]) 它从索引 start 开始修改 arr：删除 deleteCount 个元素并在当前位置插入 elem1, ..., elemN。最后返回已被删除元素的数组。 通过例子我们可以很容易地掌握这个方法。 让我们从删除开始： 12345let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;];arr.splice(1, 1); // 从索引 1 开始删除 1 个元素alert( arr ); // [&quot;I&quot;, &quot;JavaScript&quot;] 简单，对吧？从索引 1 开始删除 1 个元素。 在下一个例子中，我们删除了 3 个元素，并用另外两个元素替换它们： 123456let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;, &quot;right&quot;, &quot;now&quot;];// remove 3 first elements and replace them with anotherarr.splice(0, 3, &quot;Let&#x27;s&quot;, &quot;dance&quot;);alert( arr ) // now [&quot;Let&#x27;s&quot;, &quot;dance&quot;, &quot;right&quot;, &quot;now&quot;] 在这里我们可以看到 splice 返回了已删除元素的数组： 123456let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;, &quot;right&quot;, &quot;now&quot;];// 删除前两个元素let removed = arr.splice(0, 2);alert( removed ); // &quot;I&quot;, &quot;study&quot; &lt;-- 被从数组中删除了的元素 我们可以将 deleteCount 设置为 0，splice 方法就能够插入元素而不用删除任何元素： 12345678let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;];// 从索引 2 开始// 删除 0 个元素// 然后插入 &quot;complex&quot; 和 &quot;language&quot;arr.splice(2, 0, &quot;complex&quot;, &quot;language&quot;);alert( arr ); // &quot;I&quot;, &quot;study&quot;, &quot;complex&quot;, &quot;language&quot;, &quot;JavaScript&quot; 允许负向索引 在这里和其他数组方法中，负向索引都是被允许的。它们从数组末尾计算位置，如下所示： 12345678let arr = [1, 2, 5];// 从索引 -1（尾端前一位）// 删除 0 个元素，// 然后插入 3 和 4arr.splice(-1, 0, 3, 4);alert( arr ); // 1,2,3,4,5 slicearr.slice 方法比 arr.splice 简单得多。 语法是： 1arr.slice([start], [end]) 它会返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组。start 和 end 都可以是负数，在这种情况下，从末尾计算索引。 它和字符串的 str.slice 方法有点像，就是把子字符串替换成子数组。 例如： 12345let arr = [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;];alert( arr.slice(1, 3) ); // e,s（复制从位置 1 到位置 3 的元素）alert( arr.slice(-2) ); // s,t（复制从位置 -2 到尾端的元素） 我们也可以不带参数地调用它：arr.slice() 会创建一个 arr 的副本。其通常用于获取副本，以进行不影响原始数组的进一步转换。 concatarr.concat 创建一个新数组，其中包含来自于其他数组和其他项的值。 语法： 1arr.concat(arg1, arg2...) 它接受任意数量的参数 —— 数组或值都可以。 结果是一个包含来自于 arr，然后是 arg1，arg2 的元素的新数组。 如果参数 argN 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。 例如： 12345678910let arr = [1, 2];// create an array from: arr and [3,4]alert( arr.concat([3, 4]) ); // 1,2,3,4// create an array from: arr and [3,4] and [5,6]alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6// create an array from: arr and [3,4], then add values 5 and 6alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6 通常，它只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加： 12345678let arr = [1, 2];let arrayLike = &#123; 0: &quot;something&quot;, length: 1&#125;;alert( arr.concat(arrayLike) ); // 1,2,[object Object] ……但是，如果类似数组的对象具有 Symbol.isConcatSpreadable 属性，那么它就会被 concat 当作一个数组来处理：此对象中的元素将被添加： 12345678910let arr = [1, 2];let arrayLike = &#123; 0: &quot;something&quot;, 1: &quot;else&quot;, [Symbol.isConcatSpreadable]: true, length: 2&#125;;alert( arr.concat(arrayLike) ); // 1,2,something,else 遍历：forEacharr.forEach 方法允许为数组的每个元素都运行一个函数。 语法： 123arr.forEach(function(item, index, array) &#123; // ... do something with item&#125;); 例如，下面这个程序显示了数组的每个元素： 12// 对每个元素调用 alert[&quot;Bilbo&quot;, &quot;Gandalf&quot;, &quot;Nazgul&quot;].forEach(alert); 而这段代码更详细地介绍了它们在目标数组中的位置： 123[&quot;Bilbo&quot;, &quot;Gandalf&quot;, &quot;Nazgul&quot;].forEach((item, index, array) =&gt; &#123; alert(`$&#123;item&#125; is at index $&#123;index&#125; in $&#123;array&#125;`);&#125;); 该函数的结果（如果它有返回）会被抛弃和忽略。 在数组中搜索现在，让我们介绍在数组中进行搜索的方法。 indexOf/lastIndexOf 和 includesarr.indexOf、arr.lastIndexOf 和 arr.includes 方法与字符串操作具有相同的语法，并且作用基本上也与字符串的方法相同，只不过这里是对数组元素而不是字符进行操作： arr.indexOf(item, from) 从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。 arr.lastIndexOf(item, from) —— 和上面相同，只是从右向左搜索。 arr.includes(item, from) —— 从索引 from 开始搜索 item，如果找到则返回 true（译注：如果没找到，则返回 false）。 例如： 1234567let arr = [1, 0, false];alert( arr.indexOf(0) ); // 1alert( arr.indexOf(false) ); // 2alert( arr.indexOf(null) ); // -1alert( arr.includes(1) ); // true 请注意，这些方法使用的是严格相等 === 比较。所以如果我们搜索 false，会精确到的确是 false 而不是数字 0。 如果我们想检查是否包含某个元素，并且不想知道确切的索引，那么 arr.includes 是首选。 此外，includes 的一个非常小的差别是它能正确处理NaN，而不像 indexOf/lastIndexOf： 123const arr = [NaN];alert( arr.indexOf(NaN) ); // -1（应该为 0，但是严格相等 === equality 对 NaN 无效）alert( arr.includes(NaN) );// true（这个结果是对的） find 和 findIndex想象一下，我们有一个对象数组。我们如何找到具有特定条件的对象？ 这时可以用 arr.find 方法。 语法如下： 1234let result = arr.find(function(item, index, array) &#123; // 如果返回 true，则返回 item 并停止迭代 // 对于假值（falsy）的情况，则返回 undefined&#125;); 依次对数组中的每个元素调用该函数： item 是元素。 index 是它的索引。 array 是数组本身。 如果它返回 true，则搜索停止，并返回 item。如果没有搜索到，则返回 undefined。 例如，我们有一个存储用户的数组，每个用户都有 id 和 name 字段。让我们找到 id == 1 的那个用户： 123456789let users = [ &#123;id: 1, name: &quot;John&quot;&#125;, &#123;id: 2, name: &quot;Pete&quot;&#125;, &#123;id: 3, name: &quot;Mary&quot;&#125;];let user = users.find(item =&gt; item.id == 1);alert(user.name); // John 在现实生活中，对象数组是很常见的，所以 find 方法非常有用。 注意在这个例子中，我们传给了 find 一个单参数函数 item =&gt; item.id == 1。这很典型，并且 find 方法的其他参数很少使用。 arr.findIndex 方法（与 arr.find 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 -1。 filterfind 方法搜索的是使函数返回 true 的第一个（单个）元素。 如果需要匹配的有很多，我们可以使用 arr.filter(fn)。 语法与 find 大致相同，但是 filter 返回的是所有匹配元素组成的数组： 1234let results = arr.filter(function(item, index, array) &#123; // 如果 true item 被 push 到 results，迭代继续 // 如果什么都没找到，则返回空数组&#125;); 例如： 12345678910let users = [ &#123;id: 1, name: &quot;John&quot;&#125;, &#123;id: 2, name: &quot;Pete&quot;&#125;, &#123;id: 3, name: &quot;Mary&quot;&#125;];// 返回前两个用户的数组let someUsers = users.filter(item =&gt; item.id &lt; 3);alert(someUsers.length); // 2 转换数组让我们继续学习进行数组转换和重新排序的方法。 maparr.map 方法是最有用和经常使用的方法之一。 它对数组的每个元素都调用函数，并返回结果数组。 语法： 123let result = arr.map(function(item, index, array) &#123; // 返回新值而不是当前元素&#125;) 例如，在这里我们将每个元素转换为它的字符串长度： 12let lengths = [&quot;Bilbo&quot;, &quot;Gandalf&quot;, &quot;Nazgul&quot;].map(item =&gt; item.length);alert(lengths); // 5,7,6 sort(fn)arr.sort 方法对数组进行 原位（in-place） 排序，更改元素的顺序。(译注：原位是指在此数组内，而非生成一个新数组。) 它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 arr 本身。 语法： 123456let arr = [ 1, 2, 15 ];// 该方法重新排列 arr 的内容arr.sort();alert( arr ); // 1, 15, 2 你有没有注意到结果有什么奇怪的地方？ 顺序变成了 1, 15, 2。不对，但为什么呢？ 这些元素默认情况下被按字符串进行排序。 从字面上看，所有元素都被转换为字符串，然后进行比较。对于字符串，按照词典顺序进行排序，实际上应该是 &quot;2&quot; &gt; &quot;15&quot;。 要使用我们自己的排序顺序，我们需要提供一个函数作为 arr.sort() 的参数。 该函数应该比较两个任意值并返回： 12345function compare(a, b) &#123; if (a &gt; b) return 1; // 如果第一个值比第二个值大 if (a == b) return 0; // 如果两个值相等 if (a &lt; b) return -1; // 如果第一个值比第二个值小&#125; 例如，按数字进行排序： 1234567891011function compareNumeric(a, b) &#123; if (a &gt; b) return 1; if (a == b) return 0; if (a &lt; b) return -1;&#125;let arr = [ 1, 2, 15 ];arr.sort(compareNumeric);alert(arr); // 1, 2, 15 现在结果符合预期了。 我们思考一下这儿发生了什么。arr 可以是由任何内容组成的数组，对吗？它可能包含数字、字符串、对象或其他任何内容。我们有一组 一些元素。要对其进行排序，我们需要一个 排序函数 来确认如何比较这些元素。默认是按字符串进行排序的。 arr.sort(fn) 方法实现了通用的排序算法。我们不需要关心它的内部工作原理（大多数情况下都是经过 快速排序 或 Timsort 算法优化的）。它将遍历数组，使用提供的函数比较其元素并对其重新排序，我们所需要的就是提供执行比较的函数 fn。 顺便说一句，如果我们想知道要比较哪些元素 —— 那么什么都不会阻止 alert 它们： 1234[1, -2, 15, 2, 0, 8].sort(function(a, b) &#123; alert( a + &quot; &lt;&gt; &quot; + b ); return a - b;&#125;); 该算法可以在此过程中，将一个元素与多个其他元素进行比较，但是它会尝试进行尽可能少的比较。 比较函数可以返回任何数字 实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。 通过这个原理我们可以编写更短的函数： 12345let arr = [ 1, 2, 15 ];arr.sort(function(a, b) &#123; return a - b; &#125;);alert(arr); // 1, 2, 15 箭头函数最好 你还记得 箭头函数 吗？这里使用箭头函数会更加简洁： 1arr.sort( (a, b) =&gt; a - b ); 这与上面更长的版本完全相同。 使用 localeCompare for strings 你记得 字符串比较 算法吗？默认情况下，它通过字母的代码比较字母。 对于许多字母，最好使用 str.localeCompare 方法正确地对字母进行排序，例如 Ö。 例如，让我们用德语对几个国家/地区进行排序： 12345let countries = [&#x27;Österreich&#x27;, &#x27;Andorra&#x27;, &#x27;Vietnam&#x27;];alert( countries.sort( (a, b) =&gt; a &gt; b ? 1 : -1) ); // Andorra, Vietnam, Österreich（错的）alert( countries.sort( (a, b) =&gt; a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam（对的！） reversearr.reverse 方法用于颠倒 arr 中元素的顺序。 例如： 1234let arr = [1, 2, 3, 4, 5];arr.reverse();alert( arr ); // 5,4,3,2,1 它也会返回颠倒后的数组 arr。 split 和 join举一个现实生活场景的例子。我们正在编写一个消息应用程序，并且该人员输入以逗号分隔的接收者列表：John, Pete, Mary。但对我们来说，名字数组比单个字符串舒适得多。怎么做才能获得这样的数组呢？ str.split(delim) 方法可以做到。它通过给定的分隔符 delim 将字符串分割成一个数组。 在下面的例子中，我们用“逗号后跟着一个空格”作为分隔符： 1234567let names = &#x27;Bilbo, Gandalf, Nazgul&#x27;;let arr = names.split(&#x27;, &#x27;);for (let name of arr) &#123; alert( `A message to $&#123;name&#125;.` ); // A message to Bilbo（和其他名字）&#125; split 方法有一个可选的第二个数字参数 —— 对数组长度的限制。如果提供了，那么额外的元素会被忽略。但实际上它很少使用： 123let arr = &#x27;Bilbo, Gandalf, Nazgul, Saruman&#x27;.split(&#x27;, &#x27;, 2);alert(arr); // Bilbo, Gandalf 拆分为字母 调用带有空参数 s 的 split(s)，会将字符串拆分为字母数组： 123let str = &quot;test&quot;;alert( str.split(&#x27;&#x27;) ); // t,e,s,t arr.join(glue) 与 split 相反。它会在它们之间创建一串由 glue 粘合的 arr 项。 例如： 12345let arr = [&#x27;Bilbo&#x27;, &#x27;Gandalf&#x27;, &#x27;Nazgul&#x27;];let str = arr.join(&#x27;;&#x27;); // 使用分号 ; 将数组粘合成字符串alert( str ); // Bilbo;Gandalf;Nazgul reduce/reduceRight当我们需要遍历一个数组时 —— 我们可以使用 forEach，for 或 for..of。 当我们需要遍历并返回每个元素的数据时 —— 我们可以使用 map。 arr.reduce 方法和 arr.reduceRight 方法和上面的种类差不多，但稍微复杂一点。它们用于根据数组计算单个值。 语法是： 123let value = arr.reduce(function(accumulator, item, index, array) &#123; // ...&#125;, [initial]); 该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。 参数： accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。 item —— 当前的数组元素。 index —— 当前索引。 arr —— 数组本身。 应用函数时，上一个函数调用的结果将作为第一个参数传递给下一个函数。 因此，第一个参数本质上是累加器，用于存储所有先前执行的组合结果。最后，它成为 reduce 的结果。 听起来复杂吗？ 掌握这个知识点的最简单的方法就是通过示例。 在这里，我们通过一行代码得到一个数组的总和： 12345let arr = [1, 2, 3, 4, 5];let result = arr.reduce((sum, current) =&gt; sum + current, 0);alert(result); // 15 传递给 reduce 的函数仅使用了 2 个参数，通常这就足够了。 让我们看看细节，到底发生了什么。 在第一次运行时，sum 的值为初始值 initial（reduce 的最后一个参数），等于 0，current 是第一个数组元素，等于 1。所以函数运行的结果是 1。 在第二次运行时，sum = 1，我们将第二个数组元素（2）与其相加并返回。 在第三次运行中，sum = 3，我们继续把下一个元素与其相加，以此类推…… 计算流程： 或者以表格的形式表示，每一行代表的是对下一个数组元素的函数调用： sum current result 第 1 次调用 0 1 1 第 2 次调用 1 2 3 第 3 次调用 3 3 6 第 4 次调用 6 4 10 第 5 次调用 10 5 15 在这里，我们可以清楚地看到上一个调用的结果如何成为下一个调用的第一个参数。 我们也可以省略初始值： 123456let arr = [1, 2, 3, 4, 5];// 删除 reduce 的初始值（没有 0）let result = arr.reduce((sum, current) =&gt; sum + current);alert( result ); // 15 结果是一样的。这是因为如果没有初始值，那么 reduce 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。 计算表与上面相同，只是去掉第一行。 但是这种使用需要非常小心。如果数组为空，那么在没有初始值的情况下调用 reduce 会导致错误。 例如： 12345let arr = [];// Error: Reduce of empty array with no initial value// 如果初始值存在，则 reduce 将为空 arr 返回它（即这个初始值）。arr.reduce((sum, current) =&gt; sum + current); 所以建议始终指定初始值。 arr.reduceRight 和 arr.reduce 方法的功能一样，只是遍历为从右到左。 Array.isArray数组是基于对象的，不构成单独的语言类型。 所以 typeof 不能帮助从数组中区分出普通对象： 12alert(typeof &#123;&#125;); // objectalert(typeof []); // same ……但是数组经常被使用，因此有一种特殊的方法用于判断：Array.isArray(value)。如果 value 是一个数组，则返回 true；否则返回 false。 123alert(Array.isArray(&#123;&#125;)); // falsealert(Array.isArray([])); // true 大多数方法都支持 “thisArg”几乎所有调用函数的数组方法 —— 比如 find，filter，map，除了 sort 是一个特例，都接受一个可选的附加参数 thisArg。 上面的部分中没有解释该参数，因为该参数很少使用。但是为了完整性，我们需要讲讲它。 以下是这些方法的完整语法： 12345arr.find(func, thisArg);arr.filter(func, thisArg);arr.map(func, thisArg);// ...// thisArg 是可选的最后一个参数 thisArg 参数的值在 func 中变为 this。 例如，在这里我们使用 army 对象方法作为过滤器，thisArg 用于传递上下文（passes the context）： 123456789101112131415161718192021let army = &#123; minAge: 18, maxAge: 27, canJoin(user) &#123; return user.age &gt;= this.minAge &amp;&amp; user.age &lt; this.maxAge; &#125;&#125;;let users = [ &#123;age: 16&#125;, &#123;age: 20&#125;, &#123;age: 23&#125;, &#123;age: 30&#125;];// 找到 army.canJoin 返回 true 的 userlet soldiers = users.filter(army.canJoin, army);alert(soldiers.length); // 2alert(soldiers[0].age); // 20alert(soldiers[1].age); // 23 如果在上面的示例中我们使用了 users.filter(army.canJoin)，那么 army.canJoin 将被作为独立函数调用，并且这时 this=undefined，从而会导致即时错误。 可以用 users.filter(user =&gt; army.canJoin(user)) 替换对 users.filter(army.canJoin, army) 的调用。前者的使用频率更高，因为对于大多数人来说，它更容易理解。 总结数组方法备忘单： 添加/删除元素： push(...items) —— 向尾端添加元素， pop() —— 从尾端提取一个元素， shift() —— 从首端提取一个元素， unshift(...items) —— 向首端添加元素， splice(pos, deleteCount, ...items) —— 从 pos 开始删除 deleteCount 个元素，并插入 items。 slice(start, end) —— 创建一个新数组，将从索引 start 到索引 end（但不包括 end）的元素复制进去。 concat(...items) —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 items。如果 items 中的任意一项是一个数组，那么就取其元素。 搜索元素： indexOf/lastIndexOf(item, pos) —— 从索引 pos 开始搜索 item，搜索到则返回该项的索引，否则返回 -1。 includes(value) —— 如果数组有 value，则返回 true，否则返回 false。 find/filter(func) —— 通过 func 过滤元素，返回使 func 返回 true 的第一个值/所有值。 findIndex 和 find 类似，但返回索引而不是值。 遍历元素： forEach(func) —— 对每个元素都调用 func，不返回任何内容。 转换数组： map(func) —— 根据对每个元素调用 func 的结果创建一个新数组。 sort(func) —— 对数组进行原位（in-place）排序，然后返回它。 reverse() —— 原位（in-place）反转数组，然后返回它。 split/join —— 将字符串转换为数组并返回。 reduce/reduceRight(func, initial) —— 通过对每个元素调用 func 计算数组上的单个值，并在调用之间传递中间结果。 其他： Array.isArray(arr) 检查 arr 是否是一个数组。 请注意，sort，reverse 和 splice 方法修改的是数组本身。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://macc03.github.io/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://macc03.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"this is a test post","slug":"this-is-a-test-post","date":"2021-07-09T12:39:45.000Z","updated":"2021-07-09T12:39:45.544Z","comments":true,"path":"this-is-a-test-post/","link":"","permalink":"https://macc03.github.io/this-is-a-test-post/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-07-09T01:49:58.562Z","updated":"2021-07-09T01:49:58.562Z","comments":true,"path":"hello-world/","link":"","permalink":"https://macc03.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://macc03.github.io/tags/hexo/"},{"name":"javascript","slug":"javascript","permalink":"https://macc03.github.io/tags/javascript/"},{"name":"centos","slug":"centos","permalink":"https://macc03.github.io/tags/centos/"},{"name":"linux","slug":"linux","permalink":"https://macc03.github.io/tags/linux/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://macc03.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]}