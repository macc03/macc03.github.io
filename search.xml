<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo搭建个人博客</title>
      <link href="/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo搭建个人博客"><a href="#Hexo搭建个人博客" class="headerlink" title="Hexo搭建个人博客"></a>Hexo搭建个人博客</h1><h3 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><p>1.安装Nodejs(Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</p><p>进入nodejs官网，下载并安装</p><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715175935166.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715175935166.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715175935166"></p><p>2.安装Git</p><p>进入Git官网,下载安装</p><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715180032702.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715180032702.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715180032702"></p><h3 id="二、安装hexo"><a href="#二、安装hexo" class="headerlink" title="二、安装hexo"></a>二、安装hexo</h3><p>进入命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>等待安装完毕</p><h3 id="三、搭建博客"><a href="#三、搭建博客" class="headerlink" title="三、搭建博客"></a>三、搭建博客</h3><p>在D盘新建一个博客目录，右键进入Git Bash，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715180850597.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715180850597.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715180850597"></p><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715180929005.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715180929005.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715180929005"></p><p>进入浏览器，输入上面网站，可以看到服务已经运行起来</p><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715181057804.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715181057804.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715181057804"></p><p>接下来把它部署到Github账号</p><h3 id="三、部署到Github"><a href="#三、部署到Github" class="headerlink" title="三、部署到Github"></a>三、部署到Github</h3><p>新建一个Github账号,点击New新建一个仓库</p><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715181446407.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715181446407.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715181446407"></p><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715181520405.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715181520405.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715181520405"></p><p>Repository name改成你的名字+’.github.io’，比如macc03.github.io</p><p>勾上选择框,点击创建</p><h4 id="将git与远程仓库绑定"><a href="#将git与远程仓库绑定" class="headerlink" title="将git与远程仓库绑定"></a>将git与远程仓库绑定</h4><p>进入GitBash,输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>将名字和邮箱改为你的</p><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>生成公钥</p><p>进入C:\Users\user\.ssh目录，复制id_rsa.pub的内容</p><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715182132851.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715182132851.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715182132851"></p><p>进入GitHub，头像下面的设置界面，点settings，然后点SSH and GPG keys</p><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715182336763.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715182336763.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715182336763"></p><p>新建一个SSH key</p><p>粘贴就行了</p><p>编辑博客目录的_config.yml文件，把最下面的改为</p><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715182714714.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715182714714.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715182714714"></p><p>repo改为你github的仓库地址</p><h4 id="上传到GitHub"><a href="#上传到GitHub" class="headerlink" title="上传到GitHub"></a>上传到GitHub</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>安装hexo-deployer-git</p><p>在GitBash中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715183338945.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715183338945.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715183338945"></p><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715183813883.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715183813883.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715183813883"></p><p>就可以看到效果了</p><p>(ps:上传失败可能是网络问题，多试几次就好了)</p><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715183838786.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210715183838786.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210715183838786"></p><p>(完)</p><p>（功能没有做，只是静态页面）</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript的Map和Set</title>
      <link href="/Javascript%E7%9A%84Map%E5%92%8CSet/"/>
      <url>/Javascript%E7%9A%84Map%E5%92%8CSet/</url>
      
        <content type="html"><![CDATA[<h1 id="Map-and-Set（映射和集合）"><a href="#Map-and-Set（映射和集合）" class="headerlink" title="Map and Set（映射和集合）"></a>Map and Set（映射和集合）</h1><p>我们已经了解了以下复杂的数据结构：</p><ul><li>存储带键的数据（keyed）集合的对象。</li><li>存储有序集合的数组。</li></ul><p>但这还不足以应对现实情况。这就是为什么存在 <code>Map</code> 和 <code>Set</code>。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><a href="https://zh.javascript.info/map-set#map">Map</a></h2><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> 是一个带键的数据项的集合，就像一个 <code>Object</code> 一样。 但是它们最大的差别是 <code>Map</code> 允许任何类型的键（key）。</p><p>它的方法和属性如下：</p><ul><li><code>new Map()</code> —— 创建 map。</li><li><code>map.set(key, value)</code> —— 根据键存储值。</li><li><code>map.get(key)</code> —— 根据键来返回值，如果 <code>map</code> 中不存在对应的 <code>key</code>，则返回 <code>undefined</code>。</li><li><code>map.has(key)</code> —— 如果 <code>key</code> 存在则返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>map.delete(key)</code> —— 删除指定键的值。</li><li><code>map.clear()</code> —— 清空 map。</li><li><code>map.size</code> —— 返回当前元素个数。</li></ul><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;str1&#x27;</span>);   <span class="comment">// 字符串键</span></span><br><span class="line">map.set(<span class="number">1</span>, <span class="string">&#x27;num1&#x27;</span>);     <span class="comment">// 数字键</span></span><br><span class="line">map.set(<span class="literal">true</span>, <span class="string">&#x27;bool1&#x27;</span>); <span class="comment">// 布尔值键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还记得普通的 Object 吗? 它会将键转化为字符串</span></span><br><span class="line"><span class="comment">// Map 则会保留键的类型，所以下面这两个结果不同：</span></span><br><span class="line">alert( map.get(<span class="number">1</span>)   ); <span class="comment">// &#x27;num1&#x27;</span></span><br><span class="line">alert( map.get(<span class="string">&#x27;1&#x27;</span>) ); <span class="comment">// &#x27;str1&#x27;</span></span><br><span class="line"></span><br><span class="line">alert( map.size ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如我们所见，与对象不同，键不会被转换成字符串。键可以是任何类型。</p><p><strong><code>map[key]</code> 不是使用 <code>Map</code> 的正确方式</strong></p><p>虽然 <code>map[key]</code> 也有效，例如我们可以设置 <code>map[key] = 2</code>，这样会将 <code>map</code> 视为 JavaScript 的 plain object，因此它暗含了所有相应的限制（没有对象键等）。</p><p>所以我们应该使用 <code>map</code> 方法：<code>set</code> 和 <code>get</code> 等。</p><p><strong>Map 还可以使用对象作为键。</strong></p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储每个用户的来访次数</span></span><br><span class="line"><span class="keyword">let</span> visitsCountMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// john 是 Map 中的键</span></span><br><span class="line">visitsCountMap.set(john, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">alert( visitsCountMap.get(john) ); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>使用对象作为键是 <code>Map</code> 最值得注意和重要的功能之一。对于字符串键，<code>Object</code>（普通对象）也能正常使用，但对于对象键则不行。</p><p>我们来尝试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> visitsCountObj = &#123;&#125;; <span class="comment">// 尝试使用对象</span></span><br><span class="line"></span><br><span class="line">visitsCountObj[john] = <span class="number">123</span>; <span class="comment">// 尝试将 john 对象作为键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是写成了这样!</span></span><br><span class="line">alert( visitsCountObj[<span class="string">&quot;[object Object]&quot;</span>] ); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>因为 <code>visitsCountObj</code> 是一个对象，它会将所有的键如 <code>john</code> 转换为字符串，所以我们得到字符串键 <code>&quot;[object Object]&quot;</code>。这显然不是我们想要的结果。</p><p><strong><code>Map</code> 是怎么比较键的？</strong></p><p><code>Map</code> 使用 <a href="https://tc39.github.io/ecma262/#sec-samevaluezero">SameValueZero</a> 算法来比较键是否相等。它和严格等于 <code>===</code> 差不多，但区别是 <code>NaN</code> 被看成是等于 <code>NaN</code>。所以 <code>NaN</code> 也可以被用作键。</p><p>这个算法不能被改变或者自定义。</p><p><strong>链式调用</strong></p><p>每一次 <code>map.set</code> 调用都会返回 map 本身，所以我们可以进行“链式”调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.set(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;str1&#x27;</span>)</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">&#x27;num1&#x27;</span>)</span><br><span class="line">  .set(<span class="literal">true</span>, <span class="string">&#x27;bool1&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="Map-迭代"><a href="#Map-迭代" class="headerlink" title="Map 迭代"></a><a href="https://zh.javascript.info/map-set#map-die-dai">Map 迭代</a></h2><p>如果要在 <code>map</code> 里使用循环，可以使用以下三个方法：</p><ul><li><code>map.keys()</code> —— 遍历并返回所有的键（returns an iterable for keys），</li><li><code>map.values()</code> —— 遍历并返回所有的值（returns an iterable for values），</li><li><code>map.entries()</code> —— 遍历并返回所有的实体（returns an iterable for entries）<code>[key, value]</code>，<code>for..of</code> 在默认情况下使用的就是这个。</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> recipeMap = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;cucumber&#x27;</span>, <span class="number">500</span>],</span><br><span class="line">  [<span class="string">&#x27;tomatoes&#x27;</span>, <span class="number">350</span>],</span><br><span class="line">  [<span class="string">&#x27;onion&#x27;</span>,    <span class="number">50</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的键（vegetables）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> vegetable <span class="keyword">of</span> recipeMap.keys()) &#123;</span><br><span class="line">  alert(vegetable); <span class="comment">// cucumber, tomatoes, onion</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的值（amounts）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> amount <span class="keyword">of</span> recipeMap.values()) &#123;</span><br><span class="line">  alert(amount); <span class="comment">// 500, 350, 50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的实体 [key, value]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> recipeMap) &#123; <span class="comment">// 与 recipeMap.entries() 相同</span></span><br><span class="line">  alert(entry); <span class="comment">// cucumber,500 (and so on)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用插入顺序</strong></p><p>迭代的顺序与插入值的顺序相同。与普通的 <code>Object</code> 不同，<code>Map</code> 保留了此顺序。</p><p>除此之外，<code>Map</code> 有内置的 <code>forEach</code> 方法，与 <code>Array</code> 类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个键值对 (key, value) 运行 forEach 函数</span></span><br><span class="line">recipeMap.forEach( <span class="function">(<span class="params">value, key, map</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// cucumber: 500 etc</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Object-entries：从对象创建-Map"><a href="#Object-entries：从对象创建-Map" class="headerlink" title="Object.entries：从对象创建 Map"></a><a href="https://zh.javascript.info/map-set#objectentries-cong-dui-xiang-chuang-jian-map">Object.entries：从对象创建 Map</a></h2><p>当创建一个 <code>Map</code> 后，我们可以传入一个带有键值对的数组（或其它可迭代对象）来进行初始化，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键值对 [key, value] 数组</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;1&#x27;</span>,  <span class="string">&#x27;str1&#x27;</span>],</span><br><span class="line">  [<span class="number">1</span>,    <span class="string">&#x27;num1&#x27;</span>],</span><br><span class="line">  [<span class="literal">true</span>, <span class="string">&#x27;bool1&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">alert( map.get(<span class="string">&#x27;1&#x27;</span>) ); <span class="comment">// str1</span></span><br></pre></td></tr></table></figure><p>如果我们想从一个已有的普通对象（plain object）来创建一个 <code>Map</code>，那么我们可以使用内建方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">Object.entries(obj)</a>，该方法返回对象的键/值对数组，该数组格式完全按照 <code>Map</code> 所需的格式。</p><p>所以可以像下面这样从一个对象创建一个 Map：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br><span class="line"></span><br><span class="line">alert( map.get(<span class="string">&#x27;name&#x27;</span>) ); <span class="comment">// John</span></span><br></pre></td></tr></table></figure><p>这里，<code>Object.entries</code> 返回键/值对数组：<code>[ [&quot;name&quot;,&quot;John&quot;], [&quot;age&quot;, 30] ]</code>。这就是 <code>Map</code> 所需要的格式。</p><h2 id="Object-fromEntries：从-Map-创建对象"><a href="#Object-fromEntries：从-Map-创建对象" class="headerlink" title="Object.fromEntries：从 Map 创建对象"></a><a href="https://zh.javascript.info/map-set#objectfromentries-cong-map-chuang-jian-dui-xiang">Object.fromEntries：从 Map 创建对象</a></h2><p>我们刚刚已经学习了如何使用 <code>Object.entries(obj)</code> 从普通对象（plain object）创建 <code>Map</code>。</p><p><code>Object.fromEntries</code> 方法的作用是相反的：给定一个具有 <code>[key, value]</code> 键值对的数组，它会根据给定数组创建一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> prices = <span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&#x27;banana&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="string">&#x27;meat&#x27;</span>, <span class="number">4</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 prices = &#123; banana: 1, orange: 2, meat: 4 &#125;</span></span><br><span class="line"></span><br><span class="line">alert(prices.orange); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>我们可以使用 <code>Object.fromEntries</code> 从 <code>Map</code> 得到一个普通对象（plain object）。</p><p>例如，我们在 <code>Map</code> 中存储了一些数据，但是我们需要把这些数据传给需要普通对象（plain object）的第三方代码。</p><p>我们来开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;banana&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">map.set(<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">map.set(<span class="string">&#x27;meat&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(map.entries()); <span class="comment">// 创建一个普通对象（plain object）(*)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成了！</span></span><br><span class="line"><span class="comment">// obj = &#123; banana: 1, orange: 2, meat: 4 &#125;</span></span><br><span class="line"></span><br><span class="line">alert(obj.orange); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>调用 <code>map.entries()</code> 将返回一个可迭代的键/值对，这刚好是 <code>Object.fromEntries</code> 所需要的格式。</p><p>我们可以把带 <code>(*)</code> 这一行写得更短：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(map); <span class="comment">// 省掉 .entries()</span></span><br></pre></td></tr></table></figure><p>上面的代码作用也是一样的，因为 <code>Object.fromEntries</code> 期望得到一个可迭代对象作为参数，而不一定是数组。并且 <code>map</code> 的标准迭代会返回跟 <code>map.entries()</code> 一样的键/值对。因此，我们可以获得一个普通对象（plain object），其键/值对与 <code>map</code> 相同。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><a href="https://zh.javascript.info/map-set#set">Set</a></h2><p><code>Set</code> 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。</p><p>它的主要方法如下：</p><ul><li><code>new Set(iterable)</code> —— 创建一个 <code>set</code>，如果提供了一个 <code>iterable</code> 对象（通常是数组），将会从数组里面复制值到 <code>set</code> 中。</li><li><code>set.add(value)</code> —— 添加一个值，返回 set 本身</li><li><code>set.delete(value)</code> —— 删除值，如果 <code>value</code> 在这个方法调用的时候存在则返回 <code>true</code> ，否则返回 <code>false</code>。</li><li><code>set.has(value)</code> —— 如果 <code>value</code> 在 set 中，返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>set.clear()</code> —— 清空 set。</li><li><code>set.size</code> —— 返回元素个数。</li></ul><p>它的主要特点是，重复使用同一个值调用 <code>set.add(value)</code> 并不会发生什么改变。这就是 <code>Set</code> 里面的每一个值只出现一次的原因。</p><p>例如，我们有客人来访，我们想记住他们每一个人。但是已经来访过的客人再次来访，不应造成重复记录。每个访客必须只被“计数”一次。</p><p><code>Set</code> 可以帮助我们解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> pete = &#123; <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mary = &#123; <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// visits，一些访客来访好几次</span></span><br><span class="line">set.add(john);</span><br><span class="line">set.add(pete);</span><br><span class="line">set.add(mary);</span><br><span class="line">set.add(john);</span><br><span class="line">set.add(mary);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 只保留不重复的值</span></span><br><span class="line">alert( set.size ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> user <span class="keyword">of</span> set) &#123;</span><br><span class="line">  alert(user.name); <span class="comment">// John（然后 Pete 和 Mary）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Set</code> 的替代方法可以是一个用户数组，用 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/find">arr.find</a> 在每次插入值时检查是否重复。但是这样性能会很差，因为这个方法会遍历整个数组来检查每个元素。<code>Set</code> 内部对唯一性检查进行了更好的优化。</p><h2 id="Set-迭代（iteration）"><a href="#Set-迭代（iteration）" class="headerlink" title="Set 迭代（iteration）"></a><a href="https://zh.javascript.info/map-set#set-die-dai-iteration">Set 迭代（iteration）</a></h2><p>我们可以使用 <code>for..of</code> 或 <code>forEach</code> 来遍历 Set：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;oranges&quot;</span>, <span class="string">&quot;apples&quot;</span>, <span class="string">&quot;bananas&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> set) alert(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 forEach 相同：</span></span><br><span class="line">set.forEach(<span class="function">(<span class="params">value, valueAgain, set</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意一件有趣的事儿。<code>forEach</code> 的回调函数有三个参数：一个 <code>value</code>，然后是 <strong>同一个值</strong> <code>valueAgain</code>，最后是目标对象。没错，同一个值在参数里出现了两次。</p><p><code>forEach</code> 的回调函数有三个参数，是为了与 <code>Map</code> 兼容。当然，这看起来确实有些奇怪。但是这对在特定情况下轻松地用 <code>Set</code> 代替 <code>Map</code> 很有帮助，反之亦然。</p><p><code>Map</code> 中用于迭代的方法在 <code>Set</code> 中也同样支持：</p><ul><li><code>set.keys()</code> —— 遍历并返回所有的值（returns an iterable object for values），</li><li><code>set.values()</code> —— 与 <code>set.keys()</code> 作用相同，这是为了兼容 <code>Map</code>，</li><li><code>set.entries()</code> —— 遍历并返回所有的实体（returns an iterable object for entries）<code>[value, value]</code>，它的存在也是为了兼容 <code>Map</code>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/map-set#zong-jie">总结</a></h2><p><code>Map</code> —— 是一个带键的数据项的集合。</p><p>方法和属性如下：</p><ul><li><code>new Map([iterable])</code> —— 创建 map，可选择带有 <code>[key,value]</code> 对的 <code>iterable</code>（例如数组）来进行初始化。</li><li><code>map.set(key, value)</code> —— 根据键存储值。</li><li><code>map.get(key)</code> —— 根据键来返回值，如果 <code>map</code> 中不存在对应的 <code>key</code>，则返回 <code>undefined</code>。</li><li><code>map.has(key)</code> —— 如果 <code>key</code> 存在则返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>map.delete(key)</code> —— 删除指定键的值。</li><li><code>map.clear()</code> —— 清空 map 。</li><li><code>map.size</code> —— 返回当前元素个数。</li></ul><p>与普通对象 <code>Object</code> 的不同点：</p><ul><li>任何键、对象都可以作为键。</li><li>有其他的便捷方法，如 <code>size</code> 属性。</li></ul><p><code>Set</code> —— 是一组唯一值的集合。</p><p>方法和属性：</p><ul><li><code>new Set([iterable])</code> —— 创建 set，可选择带有 <code>iterable</code>（例如数组）来进行初始化。</li><li><code>set.add(value)</code> —— 添加一个值（如果 <code>value</code> 存在则不做任何修改），返回 set 本身。</li><li><code>set.delete(value)</code> —— 删除值，如果 <code>value</code> 在这个方法调用的时候存在则返回 <code>true</code> ，否则返回 <code>false</code>。</li><li><code>set.has(value)</code> —— 如果 <code>value</code> 在 set 中，返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>set.clear()</code> —— 清空 set。</li><li><code>set.size</code> —— 元素的个数。</li></ul><p>在 <code>Map</code> 和 <code>Set</code> 中迭代总是按照值插入的顺序进行的，所以我们不能说这些集合是无序的，但是我们不能对元素进行重新排序，也不能直接按其编号来获取元素。</p><p>(转)<a href="https://zh.javascript.info/map-set">https://zh.javascript.info/map-set</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos入门基础知识</title>
      <link href="/Centos%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/Centos%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos入门基础知识"><a href="#Centos入门基础知识" class="headerlink" title="Centos入门基础知识"></a>Centos入门基础知识</h1><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210619134020492.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210619134020492.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210619134020492"></p><p><code>cd /</code>进入根目录。输入命令 <code>ls</code>查看子目录，这些名字是有颜色的：</p><ul><li>蓝色 ：文件夹</li><li>灰色：普通文件</li><li>绿色：可执行文件</li><li>红色：压缩文件</li><li>天蓝色：链接文件（快捷方式）</li><li></li></ul><p>常用目录的作用如下：</p><ul><li><strong>bin：</strong> 存放普通用户可执行的指令，普通用户也可以执行；</li><li><strong>dev ：</strong> 设备目录，所有的硬件设备及周边均放置在这个设备目录中；</li><li><strong>boot ：</strong> 开机引导目录，包括 Linux 内核文件与开机所需要的文件；</li><li><strong>home：</strong> 这里主要存放你的个人数据，具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：<code>/home/用户名</code>。当然，root 用户除外；</li><li><strong>usr：</strong> 应用程序放置目录；</li><li><strong>lib：</strong> 开机时常用的动态链接库，bin 及 sbin 指令也会调用对应的 lib 库；</li><li><strong>tmp：</strong> 临时文件存放目录 ；</li><li><strong>etc：</strong> 各种配置文件目录，大部分配置属性均存放在这里；</li></ul><h2 id="1-2-目录相关命令"><a href="#1-2-目录相关命令" class="headerlink" title="1.2 目录相关命令"></a>1.2 目录相关命令</h2><p><img src="https://pic1.zhimg.com/80/v2-1782160e5ad070595d32d519b2dd688c_720w.jpg" class="lazyload" data-srcset="https://pic1.zhimg.com/80/v2-1782160e5ad070595d32d519b2dd688c_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>还有几个常用的快捷键：</p><p><img src="https://pic2.zhimg.com/80/v2-89bd2c49455d11ee5a7e49409adbda9d_720w.jpg" class="lazyload" data-srcset="https://pic2.zhimg.com/80/v2-89bd2c49455d11ee5a7e49409adbda9d_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h2 id="2-vim-编辑器使用方法"><a href="#2-vim-编辑器使用方法" class="headerlink" title="2. vim 编辑器使用方法"></a>2. vim 编辑器使用方法</h2><p>vim 编辑器是 CentOS 系统中使用频率比较高的编辑器，掌握基本使用方法对以后的工作有很大帮助。</p><p>通过 <code>vim &lt;文件名&gt;</code> 的方式可以编辑某文档，如果文档名不存在，那么会新建一个文档来进行编辑。</p><p><img src="https://pic1.zhimg.com/80/v2-92d1e0c9711d67d7b78b4bbda7b70ac0_720w.jpg" class="lazyload" data-srcset="https://pic1.zhimg.com/80/v2-92d1e0c9711d67d7b78b4bbda7b70ac0_720w.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js正则表达式</title>
      <link href="/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="js正则表达式"><a href="#js正则表达式" class="headerlink" title="js正则表达式"></a>js正则表达式</h3><p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p><p><strong>search() 方法</strong> 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</p><p><strong>replace() 方法</strong> 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Visit Runoob!&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> n = str.search(<span class="regexp">/Runoob/i</span>);</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210522164440337.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210522164440337.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210522164440337"></p><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210522164521063.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210522164521063.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210522164521063"></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css Flex 布局</title>
      <link href="/Css-Flex-%E5%B8%83%E5%B1%80/"/>
      <url>/Css-Flex-%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="Flex布局–弹性盒模型"><a href="#Flex布局–弹性盒模型" class="headerlink" title="Flex布局–弹性盒模型"></a>Flex布局–弹性盒模型</h3><p>转：<a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><p><img src="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210612104539334.png" class="lazyload" data-srcset="C:\Users\Uni\AppData\Roaming\Typora\typora-user-images\image-20210612104539334.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210612104539334"></p><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/">垂直居中</a>就不容易实现。</p><h2 id="一、Flex布局是什么？"><a href="#一、Flex布局是什么？" class="headerlink" title="一、Flex布局是什么？"></a>一、Flex布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局。</p><p>任何一个容器指定为<strong>flex</strong>布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用<strong>flex布局</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: -webkit-flex; /* Safari */</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h3 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h3><p>以下6个属性设置在容器上。</p><ul><li>flex-direction （属性决定主轴的方向（即项目的排列方向）。）</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h4 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h4><p>属性决定主轴的方向（即项目的排列方向）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul><h4 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h4><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可能取三个值。</p><p>（1）<code>nowrap</code>（默认）：不换行。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>（2）<code>wrap</code>：换行，第一行在上方</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h4 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-flow: <span class="tag">&lt;<span class="name">flex-direction</span>&gt;</span> || <span class="tag">&lt;<span class="name">flex-wrap</span>&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h4><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><h4 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h4><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h4 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h4><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul><h4 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h4><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  order: <span class="tag">&lt;<span class="name">integer</span>&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h4 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h4><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-grow: <span class="tag">&lt;<span class="name">number</span>&gt;</span>; /* default 0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h4 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h4><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: <span class="tag">&lt;<span class="name">number</span>&gt;</span>; /* default 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><h4 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h4><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-basis: <span class="tag">&lt;<span class="name">length</span>&gt;</span> | auto; /* default auto */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h4 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h4><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h4 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h4><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" class="lazyload" data-srcset="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><p>(完)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Javascript的数组方法</title>
      <link href="/Javascript%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
      <url>/Javascript%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h1><p>转载自<a href="https://zh.javascript.info/array-methods">https://zh.javascript.info/array-methods</a></p><p>数组提供的方法有很多。为了方便起见，在本章中，我们将按组讲解。</p><h2 id="添加-移除数组元素"><a href="#添加-移除数组元素" class="headerlink" title="添加/移除数组元素"></a><a href="https://zh.javascript.info/array-methods#tian-jia-yi-chu-shu-zu-yuan-su">添加/移除数组元素</a></h2><p>我们已经学了从数组的首端或尾端添加和删除元素的方法：</p><ul><li><code>arr.push(...items)</code> —— 从尾端添加元素，</li><li><code>arr.pop()</code> —— 从尾端提取元素，</li><li><code>arr.shift()</code> —— 从首端提取元素，</li><li><code>arr.unshift(...items)</code> —— 从首端添加元素。</li></ul><p>这里还有其他几种方法。</p><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a><a href="https://zh.javascript.info/array-methods#splice">splice</a></h3><p>如何从数组中删除元素？</p><p>数组是对象，所以我们可以尝试使用 <code>delete</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;home&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">1</span>]; <span class="comment">// remove &quot;go&quot;</span></span><br><span class="line"></span><br><span class="line">alert( arr[<span class="number">1</span>] ); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// now arr = [&quot;I&quot;,  , &quot;home&quot;];</span></span><br><span class="line">alert( arr.length ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>元素被删除了，但数组仍然有 3 个元素，我们可以看到 <code>arr.length == 3</code>。</p><p>这很正常，因为 <code>delete obj.key</code> 是通过 <code>key</code> 来移除对应的值。对于对象来说是可以的。但是对于数组来说，我们通常希望剩下的元素能够移动并占据被释放的位置。我们希望得到一个更短的数组。</p><p>所以应该使用特殊的方法。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/splice">arr.splice</a> 方法可以说是处理数组的瑞士军刀。它可以做所有事情：添加，删除和插入元素。</p><p>语法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(start[, deleteCount, elem1, ..., elemN])</span><br></pre></td></tr></table></figure><p>它从索引 <code>start</code> 开始修改 <code>arr</code>：删除 <code>deleteCount</code> 个元素并在当前位置插入 <code>elem1, ..., elemN</code>。最后返回已被删除元素的数组。</p><p>通过例子我们可以很容易地掌握这个方法。</p><p>让我们从删除开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>];</span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 从索引 1 开始删除 1 个元素</span></span><br><span class="line"></span><br><span class="line">alert( arr ); <span class="comment">// [&quot;I&quot;, &quot;JavaScript&quot;]</span></span><br></pre></td></tr></table></figure><p>简单，对吧？从索引 <code>1</code> 开始删除 <code>1</code> 个元素。</p><p>在下一个例子中，我们删除了 3 个元素，并用另外两个元素替换它们：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;now&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove 3 first elements and replace them with another</span></span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Let&#x27;s&quot;</span>, <span class="string">&quot;dance&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert( arr ) <span class="comment">// now [&quot;Let&#x27;s&quot;, &quot;dance&quot;, &quot;right&quot;, &quot;now&quot;]</span></span><br></pre></td></tr></table></figure><p>在这里我们可以看到 <code>splice</code> 返回了已删除元素的数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;now&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除前两个元素</span></span><br><span class="line"><span class="keyword">let</span> removed = arr.splice(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">alert( removed ); <span class="comment">// &quot;I&quot;, &quot;study&quot; &lt;-- 被从数组中删除了的元素</span></span><br></pre></td></tr></table></figure><p>我们可以将 <code>deleteCount</code> 设置为 <code>0</code>，<code>splice</code> 方法就能够插入元素而不用删除任何元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引 2 开始</span></span><br><span class="line"><span class="comment">// 删除 0 个元素</span></span><br><span class="line"><span class="comment">// 然后插入 &quot;complex&quot; 和 &quot;language&quot;</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;complex&quot;</span>, <span class="string">&quot;language&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert( arr ); <span class="comment">// &quot;I&quot;, &quot;study&quot;, &quot;complex&quot;, &quot;language&quot;, &quot;JavaScript&quot;</span></span><br></pre></td></tr></table></figure><p><strong>允许负向索引</strong></p><p>在这里和其他数组方法中，负向索引都是被允许的。它们从数组末尾计算位置，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引 -1（尾端前一位）</span></span><br><span class="line"><span class="comment">// 删除 0 个元素，</span></span><br><span class="line"><span class="comment">// 然后插入 3 和 4</span></span><br><span class="line">arr.splice(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">alert( arr ); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a><a href="https://zh.javascript.info/array-methods#slice">slice</a></h3><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">arr.slice</a> 方法比 <code>arr.splice</code> 简单得多。</p><p>语法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.slice([start], [end])</span><br></pre></td></tr></table></figure><p>它会返回一个新数组，将所有从索引 <code>start</code> 到 <code>end</code>（不包括 <code>end</code>）的数组项复制到一个新的数组。<code>start</code> 和 <code>end</code> 都可以是负数，在这种情况下，从末尾计算索引。</p><p>它和字符串的 <code>str.slice</code> 方法有点像，就是把子字符串替换成子数组。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;t&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>];</span><br><span class="line"></span><br><span class="line">alert( arr.slice(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// e,s（复制从位置 1 到位置 3 的元素）</span></span><br><span class="line"></span><br><span class="line">alert( arr.slice(-<span class="number">2</span>) ); <span class="comment">// s,t（复制从位置 -2 到尾端的元素）</span></span><br></pre></td></tr></table></figure><p>我们也可以不带参数地调用它：<code>arr.slice()</code> 会创建一个 <code>arr</code> 的副本。其通常用于获取副本，以进行不影响原始数组的进一步转换。</p><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a><a href="https://zh.javascript.info/array-methods#concat">concat</a></h3><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/concat">arr.concat</a> 创建一个新数组，其中包含来自于其他数组和其他项的值。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.concat(arg1, arg2...)</span><br></pre></td></tr></table></figure><p>它接受任意数量的参数 —— 数组或值都可以。</p><p>结果是一个包含来自于 <code>arr</code>，然后是 <code>arg1</code>，<code>arg2</code> 的元素的新数组。</p><p>如果参数 <code>argN</code> 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// create an array from: arr and [3,4]</span></span><br><span class="line">alert( arr.concat([<span class="number">3</span>, <span class="number">4</span>]) ); <span class="comment">// 1,2,3,4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create an array from: arr and [3,4] and [5,6]</span></span><br><span class="line">alert( arr.concat([<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]) ); <span class="comment">// 1,2,3,4,5,6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create an array from: arr and [3,4], then add values 5 and 6</span></span><br><span class="line">alert( arr.concat([<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, <span class="number">6</span>) ); <span class="comment">// 1,2,3,4,5,6</span></span><br></pre></td></tr></table></figure><p>通常，它只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;something&quot;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( arr.concat(arrayLike) ); <span class="comment">// 1,2,[object Object]</span></span><br></pre></td></tr></table></figure><p>……但是，如果类似数组的对象具有 <code>Symbol.isConcatSpreadable</code> 属性，那么它就会被 <code>concat</code> 当作一个数组来处理：此对象中的元素将被添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;something&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;else&quot;</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert( arr.concat(arrayLike) ); <span class="comment">// 1,2,something,else</span></span><br></pre></td></tr></table></figure><h2 id="遍历：forEach"><a href="#遍历：forEach" class="headerlink" title="遍历：forEach"></a><a href="https://zh.javascript.info/array-methods#bian-li-foreach">遍历：forEach</a></h2><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">arr.forEach</a> 方法允许为数组的每个元素都运行一个函数。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do something with item</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例如，下面这个程序显示了数组的每个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个元素调用 alert</span></span><br><span class="line">[<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].forEach(alert);</span><br></pre></td></tr></table></figure><p>而这段代码更详细地介绍了它们在目标数组中的位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">`<span class="subst">$&#123;item&#125;</span> is at index <span class="subst">$&#123;index&#125;</span> in <span class="subst">$&#123;array&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>该函数的结果（如果它有返回）会被抛弃和忽略。</p><h2 id="在数组中搜索"><a href="#在数组中搜索" class="headerlink" title="在数组中搜索"></a><a href="https://zh.javascript.info/array-methods#zai-shu-zu-zhong-sou-suo">在数组中搜索</a></h2><p>现在，让我们介绍在数组中进行搜索的方法。</p><h3 id="indexOf-lastIndexOf-和-includes"><a href="#indexOf-lastIndexOf-和-includes" class="headerlink" title="indexOf/lastIndexOf 和 includes"></a><a href="https://zh.javascript.info/array-methods#indexoflastindexof-he-includes">indexOf/lastIndexOf 和 includes</a></h3><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">arr.indexOf</a>、<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf">arr.lastIndexOf</a> 和 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/includes">arr.includes</a> 方法与字符串操作具有相同的语法，并且作用基本上也与字符串的方法相同，只不过这里是对数组元素而不是字符进行操作：</p><ul><li><code>arr.indexOf(item, from)</code> 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回索引，否则返回 <code>-1</code>。</li><li><code>arr.lastIndexOf(item, from)</code> —— 和上面相同，只是从右向左搜索。</li><li><code>arr.includes(item, from)</code> —— 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回 <code>true</code>（译注：如果没找到，则返回 <code>false</code>）。</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">0</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line">alert( arr.indexOf(<span class="number">0</span>) ); <span class="comment">// 1</span></span><br><span class="line">alert( arr.indexOf(<span class="literal">false</span>) ); <span class="comment">// 2</span></span><br><span class="line">alert( arr.indexOf(<span class="literal">null</span>) ); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">alert( arr.includes(<span class="number">1</span>) ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>请注意，这些方法使用的是严格相等 <code>===</code> 比较。所以如果我们搜索 <code>false</code>，会精确到的确是 <code>false</code> 而不是数字 <code>0</code>。</p><p>如果我们想检查是否包含某个元素，并且不想知道确切的索引，那么 <code>arr.includes</code> 是首选。</p><p>此外，<code>includes</code> 的一个非常小的差别是它能正确处理<code>NaN</code>，而不像 <code>indexOf/lastIndexOf</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="literal">NaN</span>];</span><br><span class="line">alert( arr.indexOf(<span class="literal">NaN</span>) ); <span class="comment">// -1（应该为 0，但是严格相等 === equality 对 NaN 无效）</span></span><br><span class="line">alert( arr.includes(<span class="literal">NaN</span>) );<span class="comment">// true（这个结果是对的）</span></span><br></pre></td></tr></table></figure><h3 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find 和 findIndex"></a><a href="https://zh.javascript.info/array-methods#find-he-findindex">find 和 findIndex</a></h3><p>想象一下，我们有一个对象数组。我们如何找到具有特定条件的对象？</p><p>这时可以用 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/find">arr.find</a> 方法。</p><p>语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果返回 true，则返回 item 并停止迭代</span></span><br><span class="line">  <span class="comment">// 对于假值（falsy）的情况，则返回 undefined</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>依次对数组中的每个元素调用该函数：</p><ul><li><code>item</code> 是元素。</li><li><code>index</code> 是它的索引。</li><li><code>array</code> 是数组本身。</li></ul><p>如果它返回 <code>true</code>，则搜索停止，并返回 <code>item</code>。如果没有搜索到，则返回 <code>undefined</code>。</p><p>例如，我们有一个存储用户的数组，每个用户都有 <code>id</code> 和 <code>name</code> 字段。让我们找到 <code>id == 1</code> 的那个用户：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = users.find(<span class="function"><span class="params">item</span> =&gt;</span> item.id == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">alert(user.name); <span class="comment">// John</span></span><br></pre></td></tr></table></figure><p>在现实生活中，对象数组是很常见的，所以 <code>find</code> 方法非常有用。</p><p>注意在这个例子中，我们传给了 <code>find</code> 一个单参数函数 <code>item =&gt; item.id == 1</code>。这很典型，并且 <code>find</code> 方法的其他参数很少使用。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex">arr.findIndex</a> 方法（与 <code>arr.find</code> 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 <code>-1</code>。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a><a href="https://zh.javascript.info/array-methods#filter">filter</a></h3><p><code>find</code> 方法搜索的是使函数返回 <code>true</code> 的第一个（单个）元素。</p><p>如果需要匹配的有很多，我们可以使用 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">arr.filter(fn)</a>。</p><p>语法与 <code>find</code> 大致相同，但是 <code>filter</code> 返回的是所有匹配元素组成的数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果 true item 被 push 到 results，迭代继续</span></span><br><span class="line">  <span class="comment">// 如果什么都没找到，则返回空数组</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前两个用户的数组</span></span><br><span class="line"><span class="keyword">let</span> someUsers = users.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.id &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">alert(someUsers.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="转换数组"><a href="#转换数组" class="headerlink" title="转换数组"></a><a href="https://zh.javascript.info/array-methods#zhuan-huan-shu-zu">转换数组</a></h2><p>让我们继续学习进行数组转换和重新排序的方法。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a><a href="https://zh.javascript.info/array-methods#map">map</a></h3><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/map">arr.map</a> 方法是最有用和经常使用的方法之一。</p><p>它对数组的每个元素都调用函数，并返回结果数组。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回新值而不是当前元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>例如，在这里我们将每个元素转换为它的字符串长度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lengths = [<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].map(<span class="function"><span class="params">item</span> =&gt;</span> item.length);</span><br><span class="line">alert(lengths); <span class="comment">// 5,7,6</span></span><br></pre></td></tr></table></figure><h3 id="sort-fn"><a href="#sort-fn" class="headerlink" title="sort(fn)"></a><a href="https://zh.javascript.info/array-methods#sortfn">sort(fn)</a></h3><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">arr.sort</a> 方法对数组进行 <strong>原位（in-place）</strong> 排序，更改元素的顺序。(译注：原位是指在此数组内，而非生成一个新数组。)</p><p>它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 <code>arr</code> 本身。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法重新排列 arr 的内容</span></span><br><span class="line">arr.sort();</span><br><span class="line"></span><br><span class="line">alert( arr );  <span class="comment">// 1, 15, 2</span></span><br></pre></td></tr></table></figure><p>你有没有注意到结果有什么奇怪的地方？</p><p>顺序变成了 <code>1, 15, 2</code>。不对，但为什么呢？</p><p><strong>这些元素默认情况下被按字符串进行排序。</strong></p><p>从字面上看，所有元素都被转换为字符串，然后进行比较。对于字符串，按照词典顺序进行排序，实际上应该是 <code>&quot;2&quot; &gt; &quot;15&quot;</code>。</p><p>要使用我们自己的排序顺序，我们需要提供一个函数作为 <code>arr.sort()</code> 的参数。</p><p>该函数应该比较两个任意值并返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 如果第一个值比第二个值大</span></span><br><span class="line">  <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果两个值相等</span></span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果第一个值比第二个值小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，按数字进行排序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareNumeric</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span> ];</span><br><span class="line"></span><br><span class="line">arr.sort(compareNumeric);</span><br><span class="line"></span><br><span class="line">alert(arr);  <span class="comment">// 1, 2, 15</span></span><br></pre></td></tr></table></figure><p>现在结果符合预期了。</p><p>我们思考一下这儿发生了什么。<code>arr</code> 可以是由任何内容组成的数组，对吗？它可能包含数字、字符串、对象或其他任何内容。我们有一组 <strong>一些元素</strong>。要对其进行排序，我们需要一个 <strong>排序函数</strong> 来确认如何比较这些元素。默认是按字符串进行排序的。</p><p><code>arr.sort(fn)</code> 方法实现了通用的排序算法。我们不需要关心它的内部工作原理（大多数情况下都是经过 <a href="https://en.wikipedia.org/wiki/Quicksort">快速排序</a> 或 <a href="https://en.wikipedia.org/wiki/Timsort">Timsort</a> 算法优化的）。它将遍历数组，使用提供的函数比较其元素并对其重新排序，我们所需要的就是提供执行比较的函数 <code>fn</code>。</p><p>顺便说一句，如果我们想知道要比较哪些元素 —— 那么什么都不会阻止 alert 它们：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, -<span class="number">2</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">8</span>].sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  alert( a + <span class="string">&quot; &lt;&gt; &quot;</span> + b );</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>该算法可以在此过程中，将一个元素与多个其他元素进行比较，但是它会尝试进行尽可能少的比较。</p><p><strong>比较函数可以返回任何数字</strong></p><p>实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。</p><p>通过这个原理我们可以编写更短的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span> ];</span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a - b; &#125;);</span><br><span class="line"></span><br><span class="line">alert(arr);  <span class="comment">// 1, 2, 15</span></span><br></pre></td></tr></table></figure><p><strong>箭头函数最好</strong></p><p>你还记得 <a href="https://zh.javascript.info/arrow-functions-basics">箭头函数</a> 吗？这里使用箭头函数会更加简洁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.sort( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b );</span><br></pre></td></tr></table></figure><p>这与上面更长的版本完全相同。</p><p><strong>使用 <code>localeCompare</code> for strings</strong></p><p>你记得 <a href="https://zh.javascript.info/string#correct-comparisons">字符串比较</a> 算法吗？默认情况下，它通过字母的代码比较字母。</p><p>对于许多字母，最好使用 <code>str.localeCompare</code> 方法正确地对字母进行排序，例如 <code>Ö</code>。</p><p>例如，让我们用德语对几个国家/地区进行排序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> countries = [<span class="string">&#x27;Österreich&#x27;</span>, <span class="string">&#x27;Andorra&#x27;</span>, <span class="string">&#x27;Vietnam&#x27;</span>];</span><br><span class="line"></span><br><span class="line">alert( countries.sort( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a &gt; b ? <span class="number">1</span> : -<span class="number">1</span>) ); <span class="comment">// Andorra, Vietnam, Österreich（错的）</span></span><br><span class="line"></span><br><span class="line">alert( countries.sort( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.localeCompare(b) ) ); <span class="comment">// Andorra,Österreich,Vietnam（对的！）</span></span><br></pre></td></tr></table></figure><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a><a href="https://zh.javascript.info/array-methods#reverse">reverse</a></h3><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse">arr.reverse</a> 方法用于颠倒 <code>arr</code> 中元素的顺序。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.reverse();</span><br><span class="line"></span><br><span class="line">alert( arr ); <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure><p>它也会返回颠倒后的数组 <code>arr</code>。</p><h3 id="split-和-join"><a href="#split-和-join" class="headerlink" title="split 和 join"></a><a href="https://zh.javascript.info/array-methods#split-he-join">split 和 join</a></h3><p>举一个现实生活场景的例子。我们正在编写一个消息应用程序，并且该人员输入以逗号分隔的接收者列表：<code>John, Pete, Mary</code>。但对我们来说，名字数组比单个字符串舒适得多。怎么做才能获得这样的数组呢？</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/split">str.split(delim)</a> 方法可以做到。它通过给定的分隔符 <code>delim</code> 将字符串分割成一个数组。</p><p>在下面的例子中，我们用“逗号后跟着一个空格”作为分隔符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = <span class="string">&#x27;Bilbo, Gandalf, Nazgul&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = names.split(<span class="string">&#x27;, &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  alert( <span class="string">`A message to <span class="subst">$&#123;name&#125;</span>.`</span> ); <span class="comment">// A message to Bilbo（和其他名字）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>split</code> 方法有一个可选的第二个数字参数 —— 对数组长度的限制。如果提供了，那么额外的元素会被忽略。但实际上它很少使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="string">&#x27;Bilbo, Gandalf, Nazgul, Saruman&#x27;</span>.split(<span class="string">&#x27;, &#x27;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">alert(arr); <span class="comment">// Bilbo, Gandalf</span></span><br></pre></td></tr></table></figure><p><strong>拆分为字母</strong></p><p>调用带有空参数 <code>s</code> 的 <code>split(s)</code>，会将字符串拆分为字母数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">alert( str.split(<span class="string">&#x27;&#x27;</span>) ); <span class="comment">// t,e,s,t</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/join">arr.join(glue)</a> 与 <code>split</code> 相反。它会在它们之间创建一串由 <code>glue</code> 粘合的 <code>arr</code> 项。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Bilbo&#x27;</span>, <span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;Nazgul&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = arr.join(<span class="string">&#x27;;&#x27;</span>); <span class="comment">// 使用分号 ; 将数组粘合成字符串</span></span><br><span class="line"></span><br><span class="line">alert( str ); <span class="comment">// Bilbo;Gandalf;Nazgul</span></span><br></pre></td></tr></table></figure><h3 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce/reduceRight"></a><a href="https://zh.javascript.info/array-methods#reducereduceright">reduce/reduceRight</a></h3><p>当我们需要遍历一个数组时 —— 我们可以使用 <code>forEach</code>，<code>for</code> 或 <code>for..of</code>。</p><p>当我们需要遍历并返回每个元素的数据时 —— 我们可以使用 <code>map</code>。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">arr.reduce</a> 方法和 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a> 方法和上面的种类差不多，但稍微复杂一点。它们用于根据数组计算单个值。</p><p>语法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, [initial]);</span><br></pre></td></tr></table></figure><p>该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。</p><p>参数：</p><ul><li><code>accumulator</code> —— 是上一个函数调用的结果，第一次等于 <code>initial</code>（如果提供了 <code>initial</code> 的话）。</li><li><code>item</code> —— 当前的数组元素。</li><li><code>index</code> —— 当前索引。</li><li><code>arr</code> —— 数组本身。</li></ul><p>应用函数时，上一个函数调用的结果将作为第一个参数传递给下一个函数。</p><p>因此，第一个参数本质上是累加器，用于存储所有先前执行的组合结果。最后，它成为 <code>reduce</code> 的结果。</p><p>听起来复杂吗？</p><p>掌握这个知识点的最简单的方法就是通过示例。</p><p>在这里，我们通过一行代码得到一个数组的总和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">alert(result); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>传递给 <code>reduce</code> 的函数仅使用了 2 个参数，通常这就足够了。</p><p>让我们看看细节，到底发生了什么。</p><ol><li>在第一次运行时，<code>sum</code> 的值为初始值 <code>initial</code>（<code>reduce</code> 的最后一个参数），等于 0，<code>current</code> 是第一个数组元素，等于 <code>1</code>。所以函数运行的结果是 <code>1</code>。</li><li>在第二次运行时，<code>sum = 1</code>，我们将第二个数组元素（<code>2</code>）与其相加并返回。</li><li>在第三次运行中，<code>sum = 3</code>，我们继续把下一个元素与其相加，以此类推……</li></ol><p>计算流程：</p><p>或者以表格的形式表示，每一行代表的是对下一个数组元素的函数调用：</p><table><thead><tr><th align="left"></th><th align="left"><code>sum</code></th><th align="left"><code>current</code></th><th align="left"><code>result</code></th></tr></thead><tbody><tr><td align="left">第 1 次调用</td><td align="left"><code>0</code></td><td align="left"><code>1</code></td><td align="left"><code>1</code></td></tr><tr><td align="left">第 2 次调用</td><td align="left"><code>1</code></td><td align="left"><code>2</code></td><td align="left"><code>3</code></td></tr><tr><td align="left">第 3 次调用</td><td align="left"><code>3</code></td><td align="left"><code>3</code></td><td align="left"><code>6</code></td></tr><tr><td align="left">第 4 次调用</td><td align="left"><code>6</code></td><td align="left"><code>4</code></td><td align="left"><code>10</code></td></tr><tr><td align="left">第 5 次调用</td><td align="left"><code>10</code></td><td align="left"><code>5</code></td><td align="left"><code>15</code></td></tr></tbody></table><p>在这里，我们可以清楚地看到上一个调用的结果如何成为下一个调用的第一个参数。</p><p>我们也可以省略初始值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 reduce 的初始值（没有 0）</span></span><br><span class="line"><span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current);</span><br><span class="line"></span><br><span class="line">alert( result ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>结果是一样的。这是因为如果没有初始值，那么 <code>reduce</code> 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。</p><p>计算表与上面相同，只是去掉第一行。</p><p>但是这种使用需要非常小心。如果数组为空，那么在没有初始值的情况下调用 <code>reduce</code> 会导致错误。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Reduce of empty array with no initial value</span></span><br><span class="line"><span class="comment">// 如果初始值存在，则 reduce 将为空 arr 返回它（即这个初始值）。</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current);</span><br></pre></td></tr></table></figure><p>所以建议始终指定初始值。</p><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a> 和 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">arr.reduce</a> 方法的功能一样，只是遍历为从右到左。</p><h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a><a href="https://zh.javascript.info/array-methods#arrayisarray">Array.isArray</a></h2><p>数组是基于对象的，不构成单独的语言类型。</p><p>所以 <code>typeof</code> 不能帮助从数组中区分出普通对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> []); <span class="comment">// same</span></span><br></pre></td></tr></table></figure><p>……但是数组经常被使用，因此有一种特殊的方法用于判断：<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray">Array.isArray(value)</a>。如果 <code>value</code> 是一个数组，则返回 <code>true</code>；否则返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Array</span>.isArray(&#123;&#125;)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Array</span>.isArray([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="大多数方法都支持-“thisArg”"><a href="#大多数方法都支持-“thisArg”" class="headerlink" title="大多数方法都支持 “thisArg”"></a><a href="https://zh.javascript.info/array-methods#da-duo-shu-fang-fa-du-zhi-chi-thisarg">大多数方法都支持 “thisArg”</a></h2><p>几乎所有调用函数的数组方法 —— 比如 <code>find</code>，<code>filter</code>，<code>map</code>，除了 <code>sort</code> 是一个特例，都接受一个可选的附加参数 <code>thisArg</code>。</p><p>上面的部分中没有解释该参数，因为该参数很少使用。但是为了完整性，我们需要讲讲它。</p><p>以下是这些方法的完整语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.find(func, thisArg);</span><br><span class="line">arr.filter(func, thisArg);</span><br><span class="line">arr.map(func, thisArg);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// thisArg 是可选的最后一个参数</span></span><br></pre></td></tr></table></figure><p><code>thisArg</code> 参数的值在 <code>func</code> 中变为 <code>this</code>。</p><p>例如，在这里我们使用 <code>army</code> 对象方法作为过滤器，<code>thisArg</code> 用于传递上下文（passes the context）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> army = &#123;</span><br><span class="line">  <span class="attr">minAge</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">maxAge</span>: <span class="number">27</span>,</span><br><span class="line">  <span class="function"><span class="title">canJoin</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> user.age &gt;= <span class="built_in">this</span>.minAge &amp;&amp; user.age &lt; <span class="built_in">this</span>.maxAge;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">age</span>: <span class="number">16</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">age</span>: <span class="number">30</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到 army.canJoin 返回 true 的 user</span></span><br><span class="line"><span class="keyword">let</span> soldiers = users.filter(army.canJoin, army);</span><br><span class="line"></span><br><span class="line">alert(soldiers.length); <span class="comment">// 2</span></span><br><span class="line">alert(soldiers[<span class="number">0</span>].age); <span class="comment">// 20</span></span><br><span class="line">alert(soldiers[<span class="number">1</span>].age); <span class="comment">// 23</span></span><br></pre></td></tr></table></figure><p>如果在上面的示例中我们使用了 <code>users.filter(army.canJoin)</code>，那么 <code>army.canJoin</code> 将被作为独立函数调用，并且这时 <code>this=undefined</code>，从而会导致即时错误。</p><p>可以用 <code>users.filter(user =&gt; army.canJoin(user))</code> 替换对 <code>users.filter(army.canJoin, army)</code> 的调用。前者的使用频率更高，因为对于大多数人来说，它更容易理解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/array-methods#zong-jie">总结</a></h2><p>数组方法备忘单：</p><ul><li>添加/删除元素：<ul><li><code>push(...items)</code> —— 向尾端添加元素，</li><li><code>pop()</code> —— 从尾端提取一个元素，</li><li><code>shift()</code> —— 从首端提取一个元素，</li><li><code>unshift(...items)</code> —— 向首端添加元素，</li><li><code>splice(pos, deleteCount, ...items)</code> —— 从 <code>pos</code> 开始删除 <code>deleteCount</code> 个元素，并插入 <code>items</code>。</li><li><code>slice(start, end)</code> —— 创建一个新数组，将从索引 <code>start</code> 到索引 <code>end</code>（但不包括 <code>end</code>）的元素复制进去。</li><li><code>concat(...items)</code> —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 <code>items</code>。如果 <code>items</code> 中的任意一项是一个数组，那么就取其元素。</li></ul></li><li>搜索元素：<ul><li><code>indexOf/lastIndexOf(item, pos)</code> —— 从索引 <code>pos</code> 开始搜索 <code>item</code>，搜索到则返回该项的索引，否则返回 <code>-1</code>。</li><li><code>includes(value)</code> —— 如果数组有 <code>value</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>find/filter(func)</code> —— 通过 <code>func</code> 过滤元素，返回使 <code>func</code> 返回 <code>true</code> 的第一个值/所有值。</li><li><code>findIndex</code> 和 <code>find</code> 类似，但返回索引而不是值。</li></ul></li><li>遍历元素：<ul><li><code>forEach(func)</code> —— 对每个元素都调用 <code>func</code>，不返回任何内容。</li></ul></li><li>转换数组：<ul><li><code>map(func)</code> —— 根据对每个元素调用 <code>func</code> 的结果创建一个新数组。</li><li><code>sort(func)</code> —— 对数组进行原位（in-place）排序，然后返回它。</li><li><code>reverse()</code> —— 原位（in-place）反转数组，然后返回它。</li><li><code>split/join</code> —— 将字符串转换为数组并返回。</li><li><code>reduce/reduceRight(func, initial)</code> —— 通过对每个元素调用 <code>func</code> 计算数组上的单个值，并在调用之间传递中间结果。</li></ul></li><li>其他：<ul><li><code>Array.isArray(arr)</code> 检查 <code>arr</code> 是否是一个数组。</li></ul></li></ul><p>请注意，<code>sort</code>，<code>reverse</code> 和 <code>splice</code> 方法修改的是数组本身。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this is a test post</title>
      <link href="/this-is-a-test-post/"/>
      <url>/this-is-a-test-post/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
