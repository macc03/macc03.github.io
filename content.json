{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://macc03.github.io","root":"/"},"pages":[],"posts":[{"title":"Javascript的数组方法","slug":"Javascript的数组方法","date":"2021-07-11T07:35:55.000Z","updated":"2021-07-11T07:38:31.431Z","comments":true,"path":"Javascript的数组方法/","link":"","permalink":"https://macc03.github.io/Javascript%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"数组方法转载https://zh.javascript.info/array-methods 数组提供的方法有很多。为了方便起见，在本章中，我们将按组讲解。 添加/移除数组元素我们已经学了从数组的首端或尾端添加和删除元素的方法： arr.push(...items) —— 从尾端添加元素， arr.pop() —— 从尾端提取元素， arr.shift() —— 从首端提取元素， arr.unshift(...items) —— 从首端添加元素。 这里还有其他几种方法。 splice如何从数组中删除元素？ 数组是对象，所以我们可以尝试使用 delete： 12345678let arr = [&quot;I&quot;, &quot;go&quot;, &quot;home&quot;];delete arr[1]; // remove &quot;go&quot;alert( arr[1] ); // undefined// now arr = [&quot;I&quot;, , &quot;home&quot;];alert( arr.length ); // 3 元素被删除了，但数组仍然有 3 个元素，我们可以看到 arr.length == 3。 这很正常，因为 delete obj.key 是通过 key 来移除对应的值。对于对象来说是可以的。但是对于数组来说，我们通常希望剩下的元素能够移动并占据被释放的位置。我们希望得到一个更短的数组。 所以应该使用特殊的方法。 arr.splice 方法可以说是处理数组的瑞士军刀。它可以做所有事情：添加，删除和插入元素。 语法是： 1arr.splice(start[, deleteCount, elem1, ..., elemN]) 它从索引 start 开始修改 arr：删除 deleteCount 个元素并在当前位置插入 elem1, ..., elemN。最后返回已被删除元素的数组。 通过例子我们可以很容易地掌握这个方法。 让我们从删除开始： 12345let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;];arr.splice(1, 1); // 从索引 1 开始删除 1 个元素alert( arr ); // [&quot;I&quot;, &quot;JavaScript&quot;] 简单，对吧？从索引 1 开始删除 1 个元素。 在下一个例子中，我们删除了 3 个元素，并用另外两个元素替换它们： 123456let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;, &quot;right&quot;, &quot;now&quot;];// remove 3 first elements and replace them with anotherarr.splice(0, 3, &quot;Let&#x27;s&quot;, &quot;dance&quot;);alert( arr ) // now [&quot;Let&#x27;s&quot;, &quot;dance&quot;, &quot;right&quot;, &quot;now&quot;] 在这里我们可以看到 splice 返回了已删除元素的数组： 123456let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;, &quot;right&quot;, &quot;now&quot;];// 删除前两个元素let removed = arr.splice(0, 2);alert( removed ); // &quot;I&quot;, &quot;study&quot; &lt;-- 被从数组中删除了的元素 我们可以将 deleteCount 设置为 0，splice 方法就能够插入元素而不用删除任何元素： 12345678let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;];// 从索引 2 开始// 删除 0 个元素// 然后插入 &quot;complex&quot; 和 &quot;language&quot;arr.splice(2, 0, &quot;complex&quot;, &quot;language&quot;);alert( arr ); // &quot;I&quot;, &quot;study&quot;, &quot;complex&quot;, &quot;language&quot;, &quot;JavaScript&quot; 允许负向索引 在这里和其他数组方法中，负向索引都是被允许的。它们从数组末尾计算位置，如下所示： 12345678let arr = [1, 2, 5];// 从索引 -1（尾端前一位）// 删除 0 个元素，// 然后插入 3 和 4arr.splice(-1, 0, 3, 4);alert( arr ); // 1,2,3,4,5 slicearr.slice 方法比 arr.splice 简单得多。 语法是： 1arr.slice([start], [end]) 它会返回一个新数组，将所有从索引 start 到 end（不包括 end）的数组项复制到一个新的数组。start 和 end 都可以是负数，在这种情况下，从末尾计算索引。 它和字符串的 str.slice 方法有点像，就是把子字符串替换成子数组。 例如： 12345let arr = [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;];alert( arr.slice(1, 3) ); // e,s（复制从位置 1 到位置 3 的元素）alert( arr.slice(-2) ); // s,t（复制从位置 -2 到尾端的元素） 我们也可以不带参数地调用它：arr.slice() 会创建一个 arr 的副本。其通常用于获取副本，以进行不影响原始数组的进一步转换。 concatarr.concat 创建一个新数组，其中包含来自于其他数组和其他项的值。 语法： 1arr.concat(arg1, arg2...) 它接受任意数量的参数 —— 数组或值都可以。 结果是一个包含来自于 arr，然后是 arg1，arg2 的元素的新数组。 如果参数 argN 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。 例如： 12345678910let arr = [1, 2];// create an array from: arr and [3,4]alert( arr.concat([3, 4]) ); // 1,2,3,4// create an array from: arr and [3,4] and [5,6]alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6// create an array from: arr and [3,4], then add values 5 and 6alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6 通常，它只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加： 12345678let arr = [1, 2];let arrayLike = &#123; 0: &quot;something&quot;, length: 1&#125;;alert( arr.concat(arrayLike) ); // 1,2,[object Object] ……但是，如果类似数组的对象具有 Symbol.isConcatSpreadable 属性，那么它就会被 concat 当作一个数组来处理：此对象中的元素将被添加： 12345678910let arr = [1, 2];let arrayLike = &#123; 0: &quot;something&quot;, 1: &quot;else&quot;, [Symbol.isConcatSpreadable]: true, length: 2&#125;;alert( arr.concat(arrayLike) ); // 1,2,something,else 遍历：forEacharr.forEach 方法允许为数组的每个元素都运行一个函数。 语法： 123arr.forEach(function(item, index, array) &#123; // ... do something with item&#125;); 例如，下面这个程序显示了数组的每个元素： 12// 对每个元素调用 alert[&quot;Bilbo&quot;, &quot;Gandalf&quot;, &quot;Nazgul&quot;].forEach(alert); 而这段代码更详细地介绍了它们在目标数组中的位置： 123[&quot;Bilbo&quot;, &quot;Gandalf&quot;, &quot;Nazgul&quot;].forEach((item, index, array) =&gt; &#123; alert(`$&#123;item&#125; is at index $&#123;index&#125; in $&#123;array&#125;`);&#125;); 该函数的结果（如果它有返回）会被抛弃和忽略。 在数组中搜索现在，让我们介绍在数组中进行搜索的方法。 indexOf/lastIndexOf 和 includesarr.indexOf、arr.lastIndexOf 和 arr.includes 方法与字符串操作具有相同的语法，并且作用基本上也与字符串的方法相同，只不过这里是对数组元素而不是字符进行操作： arr.indexOf(item, from) 从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。 arr.lastIndexOf(item, from) —— 和上面相同，只是从右向左搜索。 arr.includes(item, from) —— 从索引 from 开始搜索 item，如果找到则返回 true（译注：如果没找到，则返回 false）。 例如： 1234567let arr = [1, 0, false];alert( arr.indexOf(0) ); // 1alert( arr.indexOf(false) ); // 2alert( arr.indexOf(null) ); // -1alert( arr.includes(1) ); // true 请注意，这些方法使用的是严格相等 === 比较。所以如果我们搜索 false，会精确到的确是 false 而不是数字 0。 如果我们想检查是否包含某个元素，并且不想知道确切的索引，那么 arr.includes 是首选。 此外，includes 的一个非常小的差别是它能正确处理NaN，而不像 indexOf/lastIndexOf： 123const arr = [NaN];alert( arr.indexOf(NaN) ); // -1（应该为 0，但是严格相等 === equality 对 NaN 无效）alert( arr.includes(NaN) );// true（这个结果是对的） find 和 findIndex想象一下，我们有一个对象数组。我们如何找到具有特定条件的对象？ 这时可以用 arr.find 方法。 语法如下： 1234let result = arr.find(function(item, index, array) &#123; // 如果返回 true，则返回 item 并停止迭代 // 对于假值（falsy）的情况，则返回 undefined&#125;); 依次对数组中的每个元素调用该函数： item 是元素。 index 是它的索引。 array 是数组本身。 如果它返回 true，则搜索停止，并返回 item。如果没有搜索到，则返回 undefined。 例如，我们有一个存储用户的数组，每个用户都有 id 和 name 字段。让我们找到 id == 1 的那个用户： 123456789let users = [ &#123;id: 1, name: &quot;John&quot;&#125;, &#123;id: 2, name: &quot;Pete&quot;&#125;, &#123;id: 3, name: &quot;Mary&quot;&#125;];let user = users.find(item =&gt; item.id == 1);alert(user.name); // John 在现实生活中，对象数组是很常见的，所以 find 方法非常有用。 注意在这个例子中，我们传给了 find 一个单参数函数 item =&gt; item.id == 1。这很典型，并且 find 方法的其他参数很少使用。 arr.findIndex 方法（与 arr.find 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 -1。 filterfind 方法搜索的是使函数返回 true 的第一个（单个）元素。 如果需要匹配的有很多，我们可以使用 arr.filter(fn)。 语法与 find 大致相同，但是 filter 返回的是所有匹配元素组成的数组： 1234let results = arr.filter(function(item, index, array) &#123; // 如果 true item 被 push 到 results，迭代继续 // 如果什么都没找到，则返回空数组&#125;); 例如： 12345678910let users = [ &#123;id: 1, name: &quot;John&quot;&#125;, &#123;id: 2, name: &quot;Pete&quot;&#125;, &#123;id: 3, name: &quot;Mary&quot;&#125;];// 返回前两个用户的数组let someUsers = users.filter(item =&gt; item.id &lt; 3);alert(someUsers.length); // 2 转换数组让我们继续学习进行数组转换和重新排序的方法。 maparr.map 方法是最有用和经常使用的方法之一。 它对数组的每个元素都调用函数，并返回结果数组。 语法： 123let result = arr.map(function(item, index, array) &#123; // 返回新值而不是当前元素&#125;) 例如，在这里我们将每个元素转换为它的字符串长度： 12let lengths = [&quot;Bilbo&quot;, &quot;Gandalf&quot;, &quot;Nazgul&quot;].map(item =&gt; item.length);alert(lengths); // 5,7,6 sort(fn)arr.sort 方法对数组进行 原位（in-place） 排序，更改元素的顺序。(译注：原位是指在此数组内，而非生成一个新数组。) 它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 arr 本身。 语法： 123456let arr = [ 1, 2, 15 ];// 该方法重新排列 arr 的内容arr.sort();alert( arr ); // 1, 15, 2 你有没有注意到结果有什么奇怪的地方？ 顺序变成了 1, 15, 2。不对，但为什么呢？ 这些元素默认情况下被按字符串进行排序。 从字面上看，所有元素都被转换为字符串，然后进行比较。对于字符串，按照词典顺序进行排序，实际上应该是 &quot;2&quot; &gt; &quot;15&quot;。 要使用我们自己的排序顺序，我们需要提供一个函数作为 arr.sort() 的参数。 该函数应该比较两个任意值并返回： 12345function compare(a, b) &#123; if (a &gt; b) return 1; // 如果第一个值比第二个值大 if (a == b) return 0; // 如果两个值相等 if (a &lt; b) return -1; // 如果第一个值比第二个值小&#125; 例如，按数字进行排序： 1234567891011function compareNumeric(a, b) &#123; if (a &gt; b) return 1; if (a == b) return 0; if (a &lt; b) return -1;&#125;let arr = [ 1, 2, 15 ];arr.sort(compareNumeric);alert(arr); // 1, 2, 15 现在结果符合预期了。 我们思考一下这儿发生了什么。arr 可以是由任何内容组成的数组，对吗？它可能包含数字、字符串、对象或其他任何内容。我们有一组 一些元素。要对其进行排序，我们需要一个 排序函数 来确认如何比较这些元素。默认是按字符串进行排序的。 arr.sort(fn) 方法实现了通用的排序算法。我们不需要关心它的内部工作原理（大多数情况下都是经过 快速排序 或 Timsort 算法优化的）。它将遍历数组，使用提供的函数比较其元素并对其重新排序，我们所需要的就是提供执行比较的函数 fn。 顺便说一句，如果我们想知道要比较哪些元素 —— 那么什么都不会阻止 alert 它们： 1234[1, -2, 15, 2, 0, 8].sort(function(a, b) &#123; alert( a + &quot; &lt;&gt; &quot; + b ); return a - b;&#125;); 该算法可以在此过程中，将一个元素与多个其他元素进行比较，但是它会尝试进行尽可能少的比较。 比较函数可以返回任何数字 实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。 通过这个原理我们可以编写更短的函数： 12345let arr = [ 1, 2, 15 ];arr.sort(function(a, b) &#123; return a - b; &#125;);alert(arr); // 1, 2, 15 箭头函数最好 你还记得 箭头函数 吗？这里使用箭头函数会更加简洁： 1arr.sort( (a, b) =&gt; a - b ); 这与上面更长的版本完全相同。 使用 localeCompare for strings 你记得 字符串比较 算法吗？默认情况下，它通过字母的代码比较字母。 对于许多字母，最好使用 str.localeCompare 方法正确地对字母进行排序，例如 Ö。 例如，让我们用德语对几个国家/地区进行排序： 12345let countries = [&#x27;Österreich&#x27;, &#x27;Andorra&#x27;, &#x27;Vietnam&#x27;];alert( countries.sort( (a, b) =&gt; a &gt; b ? 1 : -1) ); // Andorra, Vietnam, Österreich（错的）alert( countries.sort( (a, b) =&gt; a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam（对的！） reversearr.reverse 方法用于颠倒 arr 中元素的顺序。 例如： 1234let arr = [1, 2, 3, 4, 5];arr.reverse();alert( arr ); // 5,4,3,2,1 它也会返回颠倒后的数组 arr。 split 和 join举一个现实生活场景的例子。我们正在编写一个消息应用程序，并且该人员输入以逗号分隔的接收者列表：John, Pete, Mary。但对我们来说，名字数组比单个字符串舒适得多。怎么做才能获得这样的数组呢？ str.split(delim) 方法可以做到。它通过给定的分隔符 delim 将字符串分割成一个数组。 在下面的例子中，我们用“逗号后跟着一个空格”作为分隔符： 1234567let names = &#x27;Bilbo, Gandalf, Nazgul&#x27;;let arr = names.split(&#x27;, &#x27;);for (let name of arr) &#123; alert( `A message to $&#123;name&#125;.` ); // A message to Bilbo（和其他名字）&#125; split 方法有一个可选的第二个数字参数 —— 对数组长度的限制。如果提供了，那么额外的元素会被忽略。但实际上它很少使用： 123let arr = &#x27;Bilbo, Gandalf, Nazgul, Saruman&#x27;.split(&#x27;, &#x27;, 2);alert(arr); // Bilbo, Gandalf 拆分为字母 调用带有空参数 s 的 split(s)，会将字符串拆分为字母数组： 123let str = &quot;test&quot;;alert( str.split(&#x27;&#x27;) ); // t,e,s,t arr.join(glue) 与 split 相反。它会在它们之间创建一串由 glue 粘合的 arr 项。 例如： 12345let arr = [&#x27;Bilbo&#x27;, &#x27;Gandalf&#x27;, &#x27;Nazgul&#x27;];let str = arr.join(&#x27;;&#x27;); // 使用分号 ; 将数组粘合成字符串alert( str ); // Bilbo;Gandalf;Nazgul reduce/reduceRight当我们需要遍历一个数组时 —— 我们可以使用 forEach，for 或 for..of。 当我们需要遍历并返回每个元素的数据时 —— 我们可以使用 map。 arr.reduce 方法和 arr.reduceRight 方法和上面的种类差不多，但稍微复杂一点。它们用于根据数组计算单个值。 语法是： 123let value = arr.reduce(function(accumulator, item, index, array) &#123; // ...&#125;, [initial]); 该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。 参数： accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）。 item —— 当前的数组元素。 index —— 当前索引。 arr —— 数组本身。 应用函数时，上一个函数调用的结果将作为第一个参数传递给下一个函数。 因此，第一个参数本质上是累加器，用于存储所有先前执行的组合结果。最后，它成为 reduce 的结果。 听起来复杂吗？ 掌握这个知识点的最简单的方法就是通过示例。 在这里，我们通过一行代码得到一个数组的总和： 12345let arr = [1, 2, 3, 4, 5];let result = arr.reduce((sum, current) =&gt; sum + current, 0);alert(result); // 15 传递给 reduce 的函数仅使用了 2 个参数，通常这就足够了。 让我们看看细节，到底发生了什么。 在第一次运行时，sum 的值为初始值 initial（reduce 的最后一个参数），等于 0，current 是第一个数组元素，等于 1。所以函数运行的结果是 1。 在第二次运行时，sum = 1，我们将第二个数组元素（2）与其相加并返回。 在第三次运行中，sum = 3，我们继续把下一个元素与其相加，以此类推…… 计算流程： 或者以表格的形式表示，每一行代表的是对下一个数组元素的函数调用： sum current result 第 1 次调用 0 1 1 第 2 次调用 1 2 3 第 3 次调用 3 3 6 第 4 次调用 6 4 10 第 5 次调用 10 5 15 在这里，我们可以清楚地看到上一个调用的结果如何成为下一个调用的第一个参数。 我们也可以省略初始值： 123456let arr = [1, 2, 3, 4, 5];// 删除 reduce 的初始值（没有 0）let result = arr.reduce((sum, current) =&gt; sum + current);alert( result ); // 15 结果是一样的。这是因为如果没有初始值，那么 reduce 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。 计算表与上面相同，只是去掉第一行。 但是这种使用需要非常小心。如果数组为空，那么在没有初始值的情况下调用 reduce 会导致错误。 例如： 12345let arr = [];// Error: Reduce of empty array with no initial value// 如果初始值存在，则 reduce 将为空 arr 返回它（即这个初始值）。arr.reduce((sum, current) =&gt; sum + current); 所以建议始终指定初始值。 arr.reduceRight 和 arr.reduce 方法的功能一样，只是遍历为从右到左。 Array.isArray数组是基于对象的，不构成单独的语言类型。 所以 typeof 不能帮助从数组中区分出普通对象： 12alert(typeof &#123;&#125;); // objectalert(typeof []); // same ……但是数组经常被使用，因此有一种特殊的方法用于判断：Array.isArray(value)。如果 value 是一个数组，则返回 true；否则返回 false。 123alert(Array.isArray(&#123;&#125;)); // falsealert(Array.isArray([])); // true 大多数方法都支持 “thisArg”几乎所有调用函数的数组方法 —— 比如 find，filter，map，除了 sort 是一个特例，都接受一个可选的附加参数 thisArg。 上面的部分中没有解释该参数，因为该参数很少使用。但是为了完整性，我们需要讲讲它。 以下是这些方法的完整语法： 12345arr.find(func, thisArg);arr.filter(func, thisArg);arr.map(func, thisArg);// ...// thisArg 是可选的最后一个参数 thisArg 参数的值在 func 中变为 this。 例如，在这里我们使用 army 对象方法作为过滤器，thisArg 用于传递上下文（passes the context）： 123456789101112131415161718192021let army = &#123; minAge: 18, maxAge: 27, canJoin(user) &#123; return user.age &gt;= this.minAge &amp;&amp; user.age &lt; this.maxAge; &#125;&#125;;let users = [ &#123;age: 16&#125;, &#123;age: 20&#125;, &#123;age: 23&#125;, &#123;age: 30&#125;];// 找到 army.canJoin 返回 true 的 userlet soldiers = users.filter(army.canJoin, army);alert(soldiers.length); // 2alert(soldiers[0].age); // 20alert(soldiers[1].age); // 23 如果在上面的示例中我们使用了 users.filter(army.canJoin)，那么 army.canJoin 将被作为独立函数调用，并且这时 this=undefined，从而会导致即时错误。 可以用 users.filter(user =&gt; army.canJoin(user)) 替换对 users.filter(army.canJoin, army) 的调用。前者的使用频率更高，因为对于大多数人来说，它更容易理解。 总结数组方法备忘单： 添加/删除元素： push(...items) —— 向尾端添加元素， pop() —— 从尾端提取一个元素， shift() —— 从首端提取一个元素， unshift(...items) —— 向首端添加元素， splice(pos, deleteCount, ...items) —— 从 pos 开始删除 deleteCount 个元素，并插入 items。 slice(start, end) —— 创建一个新数组，将从索引 start 到索引 end（但不包括 end）的元素复制进去。 concat(...items) —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 items。如果 items 中的任意一项是一个数组，那么就取其元素。 搜索元素： indexOf/lastIndexOf(item, pos) —— 从索引 pos 开始搜索 item，搜索到则返回该项的索引，否则返回 -1。 includes(value) —— 如果数组有 value，则返回 true，否则返回 false。 find/filter(func) —— 通过 func 过滤元素，返回使 func 返回 true 的第一个值/所有值。 findIndex 和 find 类似，但返回索引而不是值。 遍历元素： forEach(func) —— 对每个元素都调用 func，不返回任何内容。 转换数组： map(func) —— 根据对每个元素调用 func 的结果创建一个新数组。 sort(func) —— 对数组进行原位（in-place）排序，然后返回它。 reverse() —— 原位（in-place）反转数组，然后返回它。 split/join —— 将字符串转换为数组并返回。 reduce/reduceRight(func, initial) —— 通过对每个元素调用 func 计算数组上的单个值，并在调用之间传递中间结果。 其他： Array.isArray(arr) 检查 arr 是否是一个数组。 请注意，sort，reverse 和 splice 方法修改的是数组本身。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://macc03.github.io/tags/javascript/"}]},{"title":"this is a test post","slug":"this-is-a-test-post","date":"2021-07-09T12:39:45.000Z","updated":"2021-07-09T12:39:45.544Z","comments":true,"path":"this-is-a-test-post/","link":"","permalink":"https://macc03.github.io/this-is-a-test-post/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-07-09T01:49:58.562Z","updated":"2021-07-09T01:49:58.562Z","comments":true,"path":"hello-world/","link":"","permalink":"https://macc03.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://macc03.github.io/tags/javascript/"}]}